# Implementation Plan: Restrict Users to Own Data

## Objective
Eliminate security vulnerability where students can manipulate `studentId` in API requests to access other students' data. Implement application-level data scoping by:
1. Removing `studentId` from public APIs - derive from JWT instead
2. Adding `student_id` foreign key to all student-personal tables
3. Enforcing data access restrictions at service layer

## Prerequisites
- Current branch: `restrict-own-data`
- Database: PostgreSQL with existing schema
- Backend: Spring Boot with jOOQ
- Auth: JWT with login claim

## Phase 1: Database Schema Changes

### File: `src/main/resources/db/migration/V1__create_schema.sql`

#### Step 1.1: Update question_response table (lines 162-171)
```sql
-- REPLACE existing question_response table definition
CREATE TABLE question_response (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_assessment_id BIGINT NOT NULL REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    question_id         BIGINT NOT NULL REFERENCES question(id),
    attribute_one_id    BIGINT NOT NULL REFERENCES attribute(id),
    value_one           NUMERIC NOT NULL,
    attribute_two_id    BIGINT REFERENCES attribute(id),
    value_two           NUMERIC
);
CREATE INDEX idx_qr_assessment ON question_response (student_assessment_id);
CREATE INDEX idx_qr_student_id ON question_response (student_id);
```

#### Step 1.2: Update student_attribute_score table (lines 174-185)
```sql
-- REPLACE existing student_attribute_score table definition
CREATE TABLE student_attribute_score (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_assessment_id BIGINT NOT NULL REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    attribute_id        BIGINT NOT NULL REFERENCES attribute(id),
    total_value         NUMERIC NOT NULL,
    normalized_value       NUMERIC NOT NULL
        CHECK (normalized_value BETWEEN -1 AND 1)
        -- Normalized attribute score for this assessment.
        -- Range: [-1, 1]. Negative values indicate strong aversion (e.g., "No" on deal-breaker questions).
        -- Positive values indicate preference or high scoring. 0 means indifferent/neutral.
    );
CREATE UNIQUE INDEX uniq_student_attr ON student_attribute_score (student_assessment_id, attribute_id);
CREATE INDEX idx_sas_student_id ON student_attribute_score (student_id);
```

#### Step 1.3: Update game_save table (lines 188-194)
```sql
-- REPLACE existing game_save table definition
CREATE TABLE game_save (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    assessment_id       BIGINT NOT NULL UNIQUE REFERENCES student_assessment(id) ON DELETE CASCADE, -- 1:1 link
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    game_data           BYTEA NOT NULL,               -- compressed JSON blob
    current_game_turn   INTEGER NOT NULL,
    last_save_date      TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_game_save_student_id ON game_save (student_id);
```

#### Step 1.4: Update game_save_history table (lines 197-202)
```sql
-- REPLACE existing game_save_history table definition
CREATE TABLE game_save_history (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    game_save_id        BIGINT NOT NULL REFERENCES game_save(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    game_turn           INTEGER NOT NULL,
    save_date           TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_gsh_student_id ON game_save_history (student_id);
```

#### Step 1.5: Update career_match table (lines 247-254)
```sql
-- REPLACE existing career_match table definition
CREATE TABLE career_match (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_assessment_id BIGINT NOT NULL REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    career_id           BIGINT NOT NULL REFERENCES career(id),
    match_score         NUMERIC NOT NULL
);
CREATE INDEX idx_career_match_assessment ON career_match (student_assessment_id);
CREATE INDEX idx_career_match_student_id ON career_match (student_id);
CREATE INDEX idx_career_match_score ON career_match (student_assessment_id, match_score DESC);
```

#### Step 1.6: Add unique constraint for active assessments (after line 157)
```sql
-- Add after student_assessment table definition
CREATE UNIQUE INDEX uniq_active_assessment 
    ON student_assessment(student_id, career_assessment_id) 
    WHERE end_date IS NULL;
```

## Phase 2: Generate jOOQ Classes

### Command to run:
```bash
./gradlew clean processResources flywayCleanEnabled flywayMigrate generateJooq
```

## Phase 3: Backend Service Layer Changes

### File: `src/main/java/com/pearson/pce/service/StudentService.java`

#### Step 3.1: Add getCurrentStudentId method
```java
// ADD this method
public Long getCurrentStudentId() {
    PceUserDetails userDetails = SecurityHelper.getCurrentUserDetails();
    String login = userDetails.getUsername();
    String orgId = userDetails.getOrgId(); // if needed for multi-tenancy
    
    StudentRecord student = dslContext
        .selectFrom(STUDENT)
        .where(STUDENT.LOGIN.eq(login))
        // .and(STUDENT.ORG_ID.eq(orgId)) // if org filtering needed
        .fetchOne();
        
    if (student == null) {
        throw new ResourceNotFoundException("Student not found for current user");
    }
    
    return student.getId();
}
```

### File: `src/main/java/com/pearson/pce/service/AssessmentService.java`

#### Step 3.2: Update startAssessment method
```java
// REPLACE existing startAssessment method
public StudentAssessmentResponse startAssessment(StudentAssessmentRequest request) {
    // Remove studentId from request, get from JWT instead
    Long studentId = studentService.getCurrentStudentId();
    Long careerAssessmentId = request.getCareerAssessmentId();
    
    // Check for existing active assessment
    StudentAssessmentRecord existing = dslContext
        .selectFrom(STUDENT_ASSESSMENT)
        .where(STUDENT_ASSESSMENT.STUDENT_ID.eq(studentId))
        .and(STUDENT_ASSESSMENT.CAREER_ASSESSMENT_ID.eq(careerAssessmentId))
        .and(STUDENT_ASSESSMENT.END_DATE.isNull())
        .fetchOne();
        
    if (existing != null) {
        throw new ValidationException("Active assessment already exists", 
            ErrorType.ASSESSMENT_ALREADY_ACTIVE);
    }
    
    // Create new assessment
    StudentAssessmentRecord record = dslContext
        .insertInto(STUDENT_ASSESSMENT)
        .set(STUDENT_ASSESSMENT.STUDENT_ID, studentId)
        .set(STUDENT_ASSESSMENT.CAREER_ASSESSMENT_ID, careerAssessmentId)
        .set(STUDENT_ASSESSMENT.START_DATE, OffsetDateTime.now())
        .returning()
        .fetchOne();
    
    return new StudentAssessmentResponse(
        record.getId(),
        1, // currentTurn
        record.getStartDate()
        // Note: removed studentId from response for student-facing API
    );
}
```

#### Step 3.3: Add assessment ownership validation
```java
// ADD this method
public void validateAssessmentOwnership(Long assessmentId) {
    Long currentStudentId = studentService.getCurrentStudentId();
    
    Integer count = dslContext
        .selectCount()
        .from(STUDENT_ASSESSMENT)
        .where(STUDENT_ASSESSMENT.ID.eq(assessmentId))
        .and(STUDENT_ASSESSMENT.STUDENT_ID.eq(currentStudentId))
        .fetchOne(0, Integer.class);
        
    if (count == 0) {
        throw new AccessForbiddenException("Assessment not accessible");
    }
}
```

### File: `src/main/java/com/pearson/pce/service/QuestionService.java`

#### Step 3.4: Update submitResponses method
```java
// UPDATE existing submitResponses method
public void submitResponses(List<QuestionResponseRequest> responses) {
    Long currentStudentId = studentService.getCurrentStudentId();
    
    for (QuestionResponseRequest response : responses) {
        // Validate assessment ownership first
        assessmentService.validateAssessmentOwnership(response.getStudentAssessmentId());
        
        // Insert with student_id
        dslContext
            .insertInto(QUESTION_RESPONSE)
            .set(QUESTION_RESPONSE.STUDENT_ASSESSMENT_ID, response.getStudentAssessmentId())
            .set(QUESTION_RESPONSE.STUDENT_ID, currentStudentId) // ADD THIS
            .set(QUESTION_RESPONSE.QUESTION_ID, response.getQuestionId())
            .set(QUESTION_RESPONSE.ATTRIBUTE_ONE_ID, response.getAttributeOneId())
            .set(QUESTION_RESPONSE.VALUE_ONE, response.getValueOne())
            .set(QUESTION_RESPONSE.ATTRIBUTE_TWO_ID, response.getAttributeTwoId())
            .set(QUESTION_RESPONSE.VALUE_TWO, response.getValueTwo())
            .execute();
    }
}
```

### File: `src/main/java/com/pearson/pce/service/GameSaveService.java`

#### Step 3.5: Update upsertGameSave method
```java
// UPDATE existing upsertGameSave method  
public void upsertGameSave(Long assessmentId, GameSaveRequest request) {
    Long currentStudentId = studentService.getCurrentStudentId();
    
    // Validate ownership
    assessmentService.validateAssessmentOwnership(assessmentId);
    
    // Upsert with student_id
    dslContext
        .insertInto(GAME_SAVE)
        .set(GAME_SAVE.ASSESSMENT_ID, assessmentId)
        .set(GAME_SAVE.STUDENT_ID, currentStudentId) // ADD THIS
        .set(GAME_SAVE.GAME_DATA, request.getGameData())
        .set(GAME_SAVE.CURRENT_GAME_TURN, request.getCurrentGameTurn())
        .set(GAME_SAVE.LAST_SAVE_DATE, OffsetDateTime.now())
        .onConflict(GAME_SAVE.ASSESSMENT_ID)
        .doUpdate()
        .set(GAME_SAVE.GAME_DATA, request.getGameData())
        .set(GAME_SAVE.CURRENT_GAME_TURN, request.getCurrentGameTurn())
        .set(GAME_SAVE.LAST_SAVE_DATE, OffsetDateTime.now())
        .execute();
        
    // Insert history record with student_id
    dslContext
        .insertInto(GAME_SAVE_HISTORY)
        .set(GAME_SAVE_HISTORY.GAME_SAVE_ID, /* get from above */)
        .set(GAME_SAVE_HISTORY.STUDENT_ID, currentStudentId) // ADD THIS  
        .set(GAME_SAVE_HISTORY.GAME_TURN, request.getCurrentGameTurn())
        .execute();
}
```

#### Step 3.6: Update getGameSave method  
```java
// UPDATE existing getGameSave method
public GameSaveResponse getGameSave(Long assessmentId) {
    Long currentStudentId = studentService.getCurrentStudentId();
    
    // Validate ownership
    assessmentService.validateAssessmentOwnership(assessmentId);
    
    // Query with double protection
    GameSaveRecord record = dslContext
        .selectFrom(GAME_SAVE)
        .where(GAME_SAVE.ASSESSMENT_ID.eq(assessmentId))
        .and(GAME_SAVE.STUDENT_ID.eq(currentStudentId)) // ADD THIS
        .fetchOne();
        
    if (record == null) {
        throw new ResourceNotFoundException("Game save not found");
    }
    
    return new GameSaveResponse(record.getGameData(), record.getCurrentGameTurn());
}
```

### File: `src/main/java/com/pearson/pce/service/ScoringService.java`

#### Step 3.7: Add StudentService dependency and update all scoring methods
```java
// ADD StudentService dependency to constructor
public ScoringService(DSLContext dslContext, ScoringUtils scoringUtils, StudentService studentService) {
    this.dslContext = dslContext;
    this.scoringUtils = scoringUtils;
    this.studentService = studentService; // ADD THIS
}

// UPDATE clearExistingScores method - add student_id filters for security
private void clearExistingScores(Long assessmentId) {
    Long currentStudentId = studentService.getCurrentStudentId();

    int careerMatchesDeleted = dslContext.deleteFrom(CAREER_MATCH)
            .where(CAREER_MATCH.STUDENT_ASSESSMENT_ID.eq(assessmentId))
            .and(CAREER_MATCH.STUDENT_ID.eq(currentStudentId)) // ADD THIS
            .execute();

    int studentScoresDeleted = dslContext.deleteFrom(STUDENT_ATTRIBUTE_SCORE)
            .where(STUDENT_ATTRIBUTE_SCORE.STUDENT_ASSESSMENT_ID.eq(assessmentId))
            .and(STUDENT_ATTRIBUTE_SCORE.STUDENT_ID.eq(currentStudentId)) // ADD THIS
            .execute();
}

// UPDATE aggregateStudentAttributeScores method - add student_id to INSERT
int rowsInserted = dslContext.insertInto(STUDENT_ATTRIBUTE_SCORE,
                STUDENT_ATTRIBUTE_SCORE.STUDENT_ASSESSMENT_ID,
                STUDENT_ATTRIBUTE_SCORE.STUDENT_ID, // ADD THIS
                STUDENT_ATTRIBUTE_SCORE.ATTRIBUTE_ID,
                STUDENT_ATTRIBUTE_SCORE.TOTAL_VALUE,
                STUDENT_ATTRIBUTE_SCORE.NORMALIZED_VALUE)
        .select(
                dslContext.select(
                                DSL.val(assessmentId),
                                DSL.val(currentStudentId), // ADD THIS
                                DSL.field("attribute_id", Long.class),
                                DSL.sum(DSL.field("value", BigDecimal.class)).as("total_value"),
                                // ... rest of query

// UPDATE calculateCareerMatches method - add student_id to INSERT
String sql = """
        INSERT INTO career_match (student_assessment_id, student_id, career_id, match_score)
        SELECT 
            ?,
            ?, // ADD THIS parameter for student_id
            ca.career_id,
            // ... rest of query

int matchesInserted = dslContext.execute(sql, 
    assessmentId, currentStudentId, assessmentId, assessmentId, assessmentId); // ADD currentStudentId parameter
```

### File: `src/main/java/com/pearson/pce/service/CareerService.java`

#### Step 3.8: Update getCareerMatches method
```java
// UPDATE existing getCareerMatches method with double protection
public List<CareerMatchResponse> getCareerMatches(Long assessmentId) {
    Long currentStudentId = studentService.getCurrentStudentId();
    
    // Validate ownership first
    assessmentService.validateAssessmentOwnership(assessmentId);
    
    // Query with additional student_id filter
    return dslContext
        .select(CAREER_MATCH.CAREER_ID, CAREER_MATCH.MATCH_SCORE)
        .from(CAREER_MATCH)
        .where(CAREER_MATCH.STUDENT_ASSESSMENT_ID.eq(assessmentId))
        .and(CAREER_MATCH.STUDENT_ID.eq(currentStudentId)) // ADD THIS
        .orderBy(CAREER_MATCH.MATCH_SCORE.desc())
        .fetch()
        .map(record -> new CareerMatchResponse(
            record.get(CAREER_MATCH.CAREER_ID),
            record.get(CAREER_MATCH.MATCH_SCORE)
        ));
}
```

#### Step 3.9: Add dependencies and update CareerService
```java
// ADD StudentService and AssessmentService dependencies to constructor
public CareerService(DSLContext dslContext, SecurityHelper securityHelper, ObjectMapper objectMapper, 
                    ScoringUtils scoringUtils, StudentService studentService, AssessmentService assessmentService) {
    this.dslContext = dslContext;
    this.securityHelper = securityHelper;
    this.objectMapper = objectMapper;
    this.scoringUtils = scoringUtils;
    this.studentService = studentService; // ADD THIS
    this.assessmentService = assessmentService; // ADD THIS
}

// UPDATE getCareerMatches method - replace duplicated ownership logic
public List<CareerMatchResponse> getCareerMatches(Long assessmentId) {
    PceUserDetails userDetails = securityHelper.getCurrentUserDetails();

    // For students, validate ownership using centralized logic
    if ("ROLE_STUDENT".equals(userDetails.getAuthorities().iterator().next().getAuthority())) {
        assessmentService.validateAssessmentOwnership(assessmentId);
    }

    // Get career matches with double protection (ownership + student_id filter)
    Long currentStudentId = "ROLE_STUDENT".equals(userDetails.getAuthorities().iterator().next().getAuthority()) 
        ? studentService.getCurrentStudentId() : null;
        
    var query = dslContext.select(CAREER_MATCH.CAREER_ID, CAREER_MATCH.MATCH_SCORE)
        .from(CAREER_MATCH)
        .where(CAREER_MATCH.STUDENT_ASSESSMENT_ID.eq(assessmentId));
        
    // Add student_id filter for students (double protection)
    if (currentStudentId != null) {
        query = query.and(CAREER_MATCH.STUDENT_ID.eq(currentStudentId));
    }
    
    return query.orderBy(CAREER_MATCH.MATCH_SCORE.desc())
        .fetchInto(CareerMatchResponse.class);
}

// UPDATE validateAssessmentAccess method - use centralized validation
private void validateAssessmentAccess(Long assessmentId, PceUserDetails userDetails) {
    // Use centralized assessment ownership validation for students
    if ("ROLE_STUDENT".equals(userDetails.getAuthorities().iterator().next().getAuthority())) {
        assessmentService.validateAssessmentOwnership(assessmentId);
    } else {
        // For teachers/admins, just verify assessment exists
        StudentAssessmentRecord assessment = dslContext.selectFrom(STUDENT_ASSESSMENT)
                .where(STUDENT_ASSESSMENT.ID.eq(assessmentId))
                .fetchOne();

        if (assessment == null) {
            throw new ResourceNotFoundException("Assessment not found");
        }
    }
}
```

## Phase 4: Controller Layer Changes

### File: `src/main/java/com/pearson/pce/api/dto/StudentAssessmentRequest.java`

#### Step 4.1: Remove studentId from request DTO
```java
// REMOVE studentId field entirely
public class StudentAssessmentRequest {
    @NotNull
    private Long careerAssessmentId;
    
    // Constructors, getters, setters
    // NO studentId field
}
```

### File: `src/main/java/com/pearson/pce/api/dto/StudentAssessmentResponse.java`

#### Step 4.2: Update response DTO
```java
// UPDATE to remove studentId from student-facing responses
public class StudentAssessmentResponse {
    private Long id;
    private Integer currentTurn;
    private OffsetDateTime startDate;
    // REMOVED: private Long studentId; // Don't expose to students
    
    // For teacher/admin endpoints, create separate DTO or conditional mapping
}
```

### File: `src/main/java/com/pearson/pce/api/AssessmentController.java`

#### Step 4.3: Update startAssessment endpoint
```java
// UPDATE method signature - remove studentId parameter
@PostMapping("/student-assessment")
public ResponseEntity<StudentAssessmentResponse> startAssessment(
    @RequestBody @Valid StudentAssessmentRequest request) {
    
    // studentId now derived inside service from JWT
    StudentAssessmentResponse response = assessmentService.startAssessment(request);
    return ResponseEntity.ok(response);
}
```

#### Step 4.4: Update completeAssessment endpoint  
```java
// ADD ownership validation
@PostMapping("/student-assessment/{id}/complete")
public ResponseEntity<Void> completeAssessment(@PathVariable Long id) {
    // Validation now happens in service layer
    assessmentService.completeAssessment(id);
    return ResponseEntity.noContent().build();
}
```

### File: `src/main/java/com/pearson/pce/api/GameSaveController.java`

#### Step 4.5: Update game save endpoints
```java
// Both endpoints now validate ownership in service layer automatically
@PutMapping("/game-save/{assessmentId}")
public ResponseEntity<Void> saveGameState(
    @PathVariable Long assessmentId,
    @RequestBody @Valid GameSaveRequest request) {
    
    gameSaveService.upsertGameSave(assessmentId, request);
    return ResponseEntity.noContent().build();
}

@GetMapping("/game-save/{assessmentId}")  
public ResponseEntity<GameSaveResponse> getGameSave(@PathVariable Long assessmentId) {
    GameSaveResponse response = gameSaveService.getGameSave(assessmentId);
    return ResponseEntity.ok(response);
}
```

### File: `src/main/java/com/pearson/pce/api/QuestionController.java`

#### Step 4.6: Update submitResponses endpoint
```java
// Ownership validation now automatic via studentId derivation
@PostMapping("/question-response")
public ResponseEntity<Void> submitResponses(
    @RequestBody @Valid List<QuestionResponseRequest> responses) {
    
    questionService.submitResponses(responses);
    return ResponseEntity.noContent().build();
}
```

### File: `src/main/java/com/pearson/pce/api/CareerController.java`

#### Step 4.7: Update career endpoints
```java
// ADD ownership validation to all assessment-based endpoints
@GetMapping("/career-match/{assessmentId}")
public ResponseEntity<List<CareerMatchResponse>> getCareerMatches(@PathVariable Long assessmentId) {
    List<CareerMatchResponse> matches = careerService.getCareerMatches(assessmentId);
    return ResponseEntity.ok(matches);
}

@GetMapping("/match/preview")
public ResponseEntity<MatchPreviewResponse> previewMatches(
    @RequestParam Long assessmentId,
    @RequestParam(required = false) String clusterCode,
    @RequestParam(required = false) Integer topN) {
    
    MatchPreviewResponse preview = careerService.previewMatches(assessmentId, clusterCode, topN);
    return ResponseEntity.ok(preview);
}
```

## Phase 5: E2E Test Updates

### File: `e2e-test/studentJourney.ts`

#### Step 5.1: Update startAssessment method (line 364)
```typescript
// CHANGE method signature and request body
async startAssessment(careerAssessmentId = 1): Promise<Assessment> {
    const assessment = await this.request<Assessment>('post', '/api/student-assessment', {
        careerAssessmentId  // REMOVED: studentId
    });
    console.log(chalk.cyan('\nAssessment created:'), {
        id: assessment.id,
        careerAssessmentId: assessment.careerAssessmentId,
        currentTurn: assessment.currentTurn
        // REMOVED: studentId from logging
    });
    return assessment;
}
```

#### Step 5.2: Update method calls (lines 810, 984, 921, 1081)
```typescript
// CHANGE all calls to remove studentId parameter
const assessment = await api.startAssessment(); // REMOVED: student.id parameter
```

#### Step 5.3: Update Assessment type (lines 87-94)
```typescript
// REMOVE studentId from type definition
type Assessment = {
    id: number;
    // studentId: number; // REMOVED
    careerAssessmentId: number;
    startDate: string;
    endDate?: string;
    currentTurn: number
};
```

#### Step 5.4: Add negative test for old API format
```typescript
// ADD new test case after line 938
console.log(chalk.bold.yellow('\nSTEP 8: Testing Old API Format Rejection...'));
try {
    const badResponse = await axios.post(`${BASE_URL}/api/student-assessment`, {
        studentId: 999,  // Should be rejected
        careerAssessmentId: 1
    }, {
        headers: api.headers()
    });
    console.log(chalk.red('ERROR: Old API format was accepted!'));
} catch (e: any) {
    if (e.response?.status === 400) {
        console.log(chalk.green('Correctly rejected old API format with studentId'));
    } else {
        throw e;
    }
}
```

## Phase 6: Documentation Updates

### File: `documents/srs/Pce Api Spec v.0.4.md`

#### Step 6.1: Update POST /api/student-assessment (lines 95-124)
```markdown
### POST /api/student-assessment

**Start a new assessment (game session)**

Starts a new student assessment for the specified career assessment. Only one active assessment is allowed per student and assessment template. Student identity is derived from JWT token.

- **Authentication:** Valid JWT and student role required
- **Request:**
```json
{
  "careerAssessmentId": 3001
}
```
- **Response:** `200 OK`
```json
{
  "id": 12345,
  "currentTurn": 1,
  "startDate": "2025-05-15T10:00Z"
}
```

**Security:** Student ID is automatically derived from the authenticated user's JWT token. This prevents students from creating assessments for other students.

**Error Responses:**
- `400 Validation Error` – Invalid request data or unknown fields
- `401 Unauthorized` – Missing/invalid JWT token
- `403 Forbidden` – Insufficient permissions
- `404 Not Found` – Assessment template not found
- `409 Conflict` – Active assessment already exists for this student
```

#### Step 6.2: Add security notes to assessment-based endpoints
```markdown
**Security Note:** All endpoints that accept `assessmentId` automatically validate that the assessment belongs to the authenticated student. Attempts to access other students' assessments will result in `403 Forbidden`.
```

## Phase 7: Validation and Testing

### Step 7.1: Database migration test
```bash
# Clean database and test migration
./gradlew flywayCleanEnabled flywayMigrate

# Verify schema
psql -d pce -c "\d question_response"
psql -d pce -c "\d student_attribute_score"  
psql -d pce -c "\d game_save"
psql -d pce -c "\d career_match"
```

### Step 7.2: jOOQ generation test
```bash
# Generate jOOQ classes and verify new student_id fields
./gradlew generateJooq

# Check generated classes have new fields
grep -r "STUDENT_ID" build/generated-src/jooq/
```

### Step 7.3: E2E test run
```bash
cd e2e-test
npm run generate-test-config
npm run test:e2e
```

### Step 7.4: Manual security test
```bash
# Test that old API format is rejected
curl -X POST http://localhost:8080/api/student-assessment \
  -H "Authorization: Bearer dev-login-student1@example.com" \
  -H "Content-Type: application/json" \
  -d '{"studentId": 999, "careerAssessmentId": 1}'
  
# Should return 400 Bad Request
```

## Rollback Plan

If issues arise, rollback by:
1. Revert `V1__create_schema.sql` changes
2. Run `./gradlew flywayCleanEnabled flywayMigrate generateJooq`
3. Revert code changes
4. Deploy previous version

## Success Criteria

- [ ] Database schema updated with `student_id` columns
- [ ] jOOQ classes generated successfully  
- [ ] All services derive `studentId` from JWT
- [ ] All student data operations scoped by `student_id`
- [ ] API no longer accepts `studentId` in requests
- [ ] E2E tests pass with new API format
- [ ] Old API format returns 400 error
- [ ] Teacher/Admin functionality unaffected
- [ ] No data leakage between students possible

This plan provides specific files, line numbers, and exact code changes needed for complete implementation.