diff --git a/config/default.json b/config/default.json
index 701444487..777b70787 100644
--- a/config/default.json
+++ b/config/default.json
@@ -141,5 +141,14 @@
     "containerName": { "env": "BLOB_STORAGE_CONTAINER_NAME" },
     "cdnBaseURL": { "env": "BLOB_STORAGE_CDN_BASE_URL" },
     "urlExpirationTime": "259200"
+  },
+  "ams": {
+    "enabled": "false",
+    "requestQueue": "ams.request",
+    "responseExchange": "ams.reply",
+    "timeout": "30000",
+    "fallbackEnabled": "true",
+    "preferProResForOrders": "false",
+    "mp4FallbackForOrders": "true"
   }
 }
diff --git a/config/test.json b/config/test.json
index 8b2f4e95c..051bed1ee 100644
--- a/config/test.json
+++ b/config/test.json
@@ -60,5 +60,14 @@
   },
   "blobStorage": {
     "containerName": "test-container"
+  },
+  "ams": {
+    "enabled": "true",
+    "requestQueue": "ams.request.test", 
+    "responseExchange": "ams.reply.test",
+    "timeout": "10000",
+    "fallbackEnabled": "false",
+    "preferProResForOrders": "true",
+    "mp4FallbackForOrders": "false"
   }
 }
diff --git a/documentation/api/schemas/remote/ams/request.yaml b/documentation/api/schemas/remote/ams/request.yaml
new file mode 100644
index 000000000..8fb769d0b
--- /dev/null
+++ b/documentation/api/schemas/remote/ams/request.yaml
@@ -0,0 +1,58 @@
+amsRequest:
+  title: AMS request
+  type: object
+  required: [type, requestId, replyTo, payload]
+  additionalProperties: false
+  properties:
+    type:
+      type: string
+      enum: [searchAssets]
+    requestId:
+      type: string
+      format: uuid
+    replyTo:
+      $ref: '#/amsRequestReplyTo'
+    payload:
+      $ref: '#/amsRequestPayload'
+
+amsRequestReplyTo:
+  title: AMS request ReplyTo
+  type: object
+  additionalProperties: false
+  required: [exchangeName, routingKey]
+  properties:
+    exchangeName:
+      type: string
+    routingKey:
+      type: string
+
+amsRequestPayload:
+  title: AMS request Payload
+  type: object
+  additionalProperties: false
+  required: [offset, limit, query]
+  properties:
+    offset:
+      type: integer
+      minimum: 0
+    limit:
+      type: integer
+      minimum: 1
+      maximum: 100
+    query:
+      $ref: '#/amsRequestQuery'
+
+amsRequestQuery:
+  title: AMS request Query
+  type: object
+  additionalProperties: false
+  required: [field, operator, value]
+  properties:
+    field:
+      type: string
+      enum: [id]
+    operator:
+      type: string
+      enum: [equals]
+    value:
+      type: string
diff --git a/documentation/api/schemas/remote/ams/response.yaml b/documentation/api/schemas/remote/ams/response.yaml
new file mode 100644
index 000000000..e8d2091b2
--- /dev/null
+++ b/documentation/api/schemas/remote/ams/response.yaml
@@ -0,0 +1,90 @@
+amsResponseSuccess:
+  title: AMS response Success
+  type: object
+  additionalProperties: false
+  required: [type, requestId, payload]
+  properties:
+    type:
+      type: string
+    requestId:
+      type: string
+      format: uuid
+    payload:
+      $ref: '#/amsResponsePayload'
+
+amsResponseError:
+  title: AMS response Error
+  type: object
+  additionalProperties: false
+  required: [type, requestId, error]
+  properties:
+    type:
+      type: string
+    requestId:
+      type: string
+      format: uuid
+    error:
+      $ref: '#/amsResponseErrorDetails'
+
+amsResponse:
+  title: AMS response
+  oneOf:
+    - $ref: '#/amsResponseSuccess'
+    - $ref: '#/amsResponseError'
+
+amsResponsePayload:
+  title: AMS response Payload
+  type: object
+  additionalProperties: false
+  required: [asset]
+  properties:
+    asset:
+      $ref: '#/amsResponseAsset'
+
+amsResponseErrorDetails:
+  title: AMS response Error Details
+  type: object
+  additionalProperties: false
+  required: [code, message]
+  properties:
+    code:
+      type: string
+    message:
+      type: string
+    details:
+      type: object
+      additionalProperties: true
+
+amsResponseAsset:
+  title: AMS response Asset
+  type: object
+  additionalProperties: false
+  required: [id, type, variations]
+  properties:
+    id:
+      type: string
+    type:
+      type: string
+      enum: [image, video]
+    variations:
+      type: array
+      items:
+        $ref: '#/amsResponseVariation'
+    metadata:
+      type: object
+      additionalProperties: true
+
+amsResponseVariation:
+  title: AMS response Variation
+  type: object
+  additionalProperties: false
+  required: [url, height, mimeType]
+  properties:
+    url:
+      type: string
+      format: uri
+    height:
+      type: integer
+      minimum: 1
+    mimeType:
+      type: string
\ No newline at end of file
diff --git a/package.json b/package.json
index aa314ef76..9a365ee44 100644
--- a/package.json
+++ b/package.json
@@ -141,6 +141,7 @@
         "test-server": "npm run test-setup & xvfb-run -a -s \"-ac -screen 0 1280x1024x24\" vitest run -c src/server/vitest.config.ts",
         "test-browser": "npm run test-setup && node test/support/viewer/esbuild.config.mjs && vitest run -c src/browser/vitest.config.ts",
         "test-operations": "HEADLESS_BENCH=true npx rsbuild --config test/operations/testBench/rsbuild.config.js build && NODE_OPTIONS=\"--experimental-vm-modules\" xvfb-run -a -s \"-ac -screen 0 1280x1024x24\" vitest run -c test/operations/vitest.config.ts",
+        "test-ams-integration": "npm run test-setup && NODE_ENV=test vitest run test/server/integration/ams.test.ts --pool=forks --poolOptions.forks.singleFork=true",
         "lint": "eslint . --ext .ts --ext .tsx",
         "paranoid": "npm run build && npm run build-test-operations && npm run test-server -- --coverage && npm run test-browser && npm run lint",
         "server": "xvfb-run -a -s \"-ac -screen 0 1280x1024x24\" node build/server/index.js",
diff --git a/src/graphics/browser/operations/loadResource.ts b/src/graphics/browser/operations/loadResource.ts
index ad89c5b19..f4a3b8726 100644
--- a/src/graphics/browser/operations/loadResource.ts
+++ b/src/graphics/browser/operations/loadResource.ts
@@ -29,29 +29,33 @@ async function loadResource(
   config: OperationImplementationConfig,
   args: RuntimeValue[]
 ): Promise<OperationImplementationResult<RuntimeValue>> {
-  if (args.length !== 2) throw new Error('Missing arguments');
+  if (args.length !== 3) throw new Error('Missing arguments');
 
-  const [resourceType, ref] = args;
-  if (typeof resourceType !== 'string' || typeof ref !== 'string')
-    throw new Error('Invalid arguments: resourceType and ref must be strings');
+  const [resourceType, ref, source] = args;
+  if (typeof resourceType !== 'string' || typeof ref !== 'string' || typeof source !== 'string')
+    throw new Error('Invalid arguments: resourceType, ref and source must be strings');
   if (!isResourceTypeName(resourceType)) throw new Error('Invalid arguments: resourceType');
+  if (source !== 'generator' && source !== 'ams') throw new Error(`Invalid source: ${source}`);
 
   const resource = await services.resourceStorage.get(
     { resourceRef: ref },
     { type: resourceType } as InteroperationType,
     config.scalingFactor
   );
-  if (!resource) throw new Error(`Resource '${ref}' of type '${resourceType}' was not found in storage`);
+  if (!resource) throw new Error(
+    `Resource '${ref}' of type '${resourceType}' from source '${source}' was not found in storage`
+  );
 
   return addSerializationId({ outputs: [{ name: 'resource', value: resource }] }, 'Load Resource', args, config);
 }
 
 function getAssetURLsImplementation(config: OperationImplementationConfig, args: AssetURLArg[]): AssetPreloadRequest[] {
-  if (args.length !== 2) return [];
+  if (args.length !== 3) return [];
 
-  const [resourceType, ref] = args;
-  if (typeof resourceType !== 'string' || typeof ref !== 'string') return [];
+  const [resourceType, ref, source] = args;
+  if (typeof resourceType !== 'string' || typeof ref !== 'string' || typeof source !== 'string') return [];
   if (!isResourceTypeName(resourceType)) return [];
+  if (source !== 'generator' && source !== 'ams') return [];
 
   return [{ resourceRef: ref, type: { type: InteroperationTypeNames[resourceType] } }];
 }
diff --git a/src/graphics/server/operations/loadResource.ts b/src/graphics/server/operations/loadResource.ts
index 6ff245865..193dbef2f 100644
--- a/src/graphics/server/operations/loadResource.ts
+++ b/src/graphics/server/operations/loadResource.ts
@@ -6,6 +6,7 @@ import type {
 import type { RuntimeValue } from 'server/types/RuntimeValue';
 import type { OperationServices } from 'server/types/OperationServices';
 import type { InteroperationType} from '../../../types/InteroperationTypes/index';
+import type { ResourceReference } from '../../../types/SourceGraph/Resource';
 import { InteroperationTypeNames } from '../../../types/InteroperationTypes/index';
 import { runInComputeBlock } from './util/runInComputeBlock';
 
@@ -27,19 +28,26 @@ async function loadResource(
   config: OperationImplementationConfig,
   args: RuntimeValue[]
 ): Promise<OperationImplementationResult<RuntimeValue>> {
-  if (args.length !== 2) throw new Error('Missing arguments');
+  if (args.length !== 3) throw new Error('Missing arguments');
 
-  const [resourceType, ref] = args;
-  if (typeof resourceType !== 'string' || typeof ref !== 'string')
-    throw new Error('Invalid arguments: resourceType and ref must be strings');
+  const [resourceType, ref, source] = args;
+  if (typeof resourceType !== 'string' || typeof ref !== 'string' || typeof source !== 'string')
+    throw new Error('Invalid arguments: resourceType, ref and source must be strings');
   if (!isResourceTypeName(resourceType)) throw new Error('Invalid arguments: resourceType');
+  if (source !== 'generator' && source !== 'ams') throw new Error(`Invalid source: ${source}`);
+
+  const resourceReference: ResourceReference =
+    source === 'generator' ? { resourceRef: ref } : { ams: ref };
 
   const resource = await services.resourceStorage.get(
-    { resourceRef: ref },
+    resourceReference,
     { type: resourceType } as InteroperationType,
     config.scalingFactor
   );
-  if (!resource) throw new Error(`Resource '${ref}' of type '${resourceType}' was not found in storage`);
+
+  if (!resource) throw new Error(
+    `Resource '${ref}' of type '${resourceType}' from source '${source}' was not found in storage`
+  );
 
   return { outputs: [{ name: 'resource', value: resource }] };
 }
diff --git a/src/graphics/server/operations/selectFrameFromVideo.ts b/src/graphics/server/operations/selectFrameFromVideo.ts
index 177a07c6d..3b9cfcdfd 100644
--- a/src/graphics/server/operations/selectFrameFromVideo.ts
+++ b/src/graphics/server/operations/selectFrameFromVideo.ts
@@ -73,7 +73,7 @@ function runFfmpeg(frameIndex: number, inputStream: stream.Readable, outputStrea
   const outputOptions = [...OUTPUT_FORMAT_OPTIONS, ...MOVE_METADATA_TO_THE_BEGINNING_OPTIONS];
 
   return new Promise((resolve, reject) => {
-    const command = ffmpeg(inputStream).inputFormat('mp4').filterGraph(filterOptions).outputOptions(outputOptions);
+    const command = ffmpeg(inputStream).filterGraph(filterOptions).outputOptions(outputOptions);
 
     command.on('error', reject);
     command.on('end', resolve);
diff --git a/src/jsonSchemas/gateways/ams/request.ts b/src/jsonSchemas/gateways/ams/request.ts
new file mode 100644
index 000000000..23c9eb2e6
--- /dev/null
+++ b/src/jsonSchemas/gateways/ams/request.ts
@@ -0,0 +1,78 @@
+/* eslint-disable unicorn/no-abusive-eslint-disable */
+/* eslint-disable */
+/*
+  WARNING!
+  This schema was automatically built from "documentation/api/schemas/remote/ams/request.yaml".
+  Please do not edit it manually.
+  Update `documentation/api/schemas` and run `npm run build-json-schema-types`.
+*/
+
+import type { JSONSchemaType } from 'ajv';
+import type { AMSRequest } from 'types/gateways/ams/request';
+
+export const amsRequestSchema: JSONSchemaType<AMSRequest> = {
+  title: 'AMS request',
+  type: 'object',
+  required: ['type', 'requestId', 'replyTo', 'payload'],
+  additionalProperties: false,
+  properties: {
+    type: {
+      type: 'string',
+      enum: ['searchAssets'],
+    },
+    requestId: {
+      type: 'string',
+      format: 'uuid',
+    },
+    replyTo: {
+      title: 'AMS request ReplyTo',
+      type: 'object',
+      additionalProperties: false,
+      required: ['exchangeName', 'routingKey'],
+      properties: {
+        exchangeName: {
+          type: 'string',
+        },
+        routingKey: {
+          type: 'string',
+        },
+      },
+    },
+    payload: {
+      title: 'AMS request Payload',
+      type: 'object',
+      additionalProperties: false,
+      required: ['offset', 'limit', 'query'],
+      properties: {
+        offset: {
+          type: 'integer',
+          minimum: 0,
+        },
+        limit: {
+          type: 'integer',
+          minimum: 1,
+          maximum: 100,
+        },
+        query: {
+          title: 'AMS request Query',
+          type: 'object',
+          additionalProperties: false,
+          required: ['field', 'operator', 'value'],
+          properties: {
+            field: {
+              type: 'string',
+              enum: ['id'],
+            },
+            operator: {
+              type: 'string',
+              enum: ['equals'],
+            },
+            value: {
+              type: 'string',
+            },
+          },
+        },
+      },
+    },
+  },
+};
diff --git a/src/jsonSchemas/gateways/ams/response.ts b/src/jsonSchemas/gateways/ams/response.ts
new file mode 100644
index 000000000..4f8030bfc
--- /dev/null
+++ b/src/jsonSchemas/gateways/ams/response.ts
@@ -0,0 +1,215 @@
+/* eslint-disable unicorn/no-abusive-eslint-disable */
+/* eslint-disable */
+/*
+  WARNING!
+  This schema was automatically built from "documentation/api/schemas/remote/ams/response.yaml".
+  Please do not edit it manually.
+  Update `documentation/api/schemas` and run `npm run build-json-schema-types`.
+*/
+
+import type { JSONSchemaType } from 'ajv';
+import type { AMSResponse } from 'types/gateways/ams/response';
+import type { AMSResponseSuccess } from 'types/gateways/ams/responseSuccess';
+import type { AMSResponseError } from 'types/gateways/ams/responseError';
+
+export const amsResponseSchema: JSONSchemaType<AMSResponse> = {
+  title: 'AMS response',
+  oneOf: [
+    {
+      title: 'AMS response Success',
+      type: 'object',
+      additionalProperties: false,
+      required: ['type', 'requestId', 'payload'],
+      properties: {
+        type: {
+          type: 'string',
+        },
+        requestId: {
+          type: 'string',
+          format: 'uuid',
+        },
+        payload: {
+          title: 'AMS response Payload',
+          type: 'object',
+          additionalProperties: false,
+          required: ['asset'],
+          properties: {
+            asset: {
+              title: 'AMS response Asset',
+              type: 'object',
+              additionalProperties: false,
+              required: ['id', 'type', 'variations'],
+              properties: {
+                id: {
+                  type: 'string',
+                },
+                type: {
+                  type: 'string',
+                  enum: ['image', 'video'],
+                },
+                variations: {
+                  type: 'array',
+                  items: {
+                    title: 'AMS response Variation',
+                    type: 'object',
+                    additionalProperties: false,
+                    required: ['url', 'height', 'mimeType'],
+                    properties: {
+                      url: {
+                        type: 'string',
+                        format: 'uri',
+                      },
+                      height: {
+                        type: 'integer',
+                        minimum: 1,
+                      },
+                      mimeType: {
+                        type: 'string',
+                      },
+                    },
+                  },
+                },
+                metadata: {
+                  type: 'object',
+                  additionalProperties: true,
+                },
+              },
+            },
+          },
+        },
+      },
+    },
+    {
+      title: 'AMS response Error',
+      type: 'object',
+      additionalProperties: false,
+      required: ['type', 'requestId', 'error'],
+      properties: {
+        type: {
+          type: 'string',
+        },
+        requestId: {
+          type: 'string',
+          format: 'uuid',
+        },
+        error: {
+          title: 'AMS response Error Details',
+          type: 'object',
+          additionalProperties: false,
+          required: ['code', 'message'],
+          properties: {
+            code: {
+              type: 'string',
+            },
+            message: {
+              type: 'string',
+            },
+            details: {
+              type: 'object',
+              additionalProperties: true,
+            },
+          },
+        },
+      },
+    },
+  ],
+};
+
+export const amsResponseSuccessSchema: JSONSchemaType<AMSResponseSuccess> = {
+  title: 'AMS response Success',
+  type: 'object',
+  additionalProperties: false,
+  required: ['type', 'requestId', 'payload'],
+  properties: {
+    type: {
+      type: 'string',
+    },
+    requestId: {
+      type: 'string',
+      format: 'uuid',
+    },
+    payload: {
+      title: 'AMS response Payload',
+      type: 'object',
+      additionalProperties: false,
+      required: ['asset'],
+      properties: {
+        asset: {
+          title: 'AMS response Asset',
+          type: 'object',
+          additionalProperties: false,
+          required: ['id', 'type', 'variations'],
+          properties: {
+            id: {
+              type: 'string',
+            },
+            type: {
+              type: 'string',
+              enum: ['image', 'video'],
+            },
+            variations: {
+              type: 'array',
+              items: {
+                title: 'AMS response Variation',
+                type: 'object',
+                additionalProperties: false,
+                required: ['url', 'height', 'mimeType'],
+                properties: {
+                  url: {
+                    type: 'string',
+                    format: 'uri',
+                  },
+                  height: {
+                    type: 'integer',
+                    minimum: 1,
+                  },
+                  mimeType: {
+                    type: 'string',
+                  },
+                },
+              },
+            },
+            metadata: {
+              type: 'object',
+              additionalProperties: true,
+            },
+          },
+        },
+      },
+    },
+  },
+};
+
+export const amsResponseErrorSchema: JSONSchemaType<AMSResponseError> = {
+  title: 'AMS response Error',
+  type: 'object',
+  additionalProperties: false,
+  required: ['type', 'requestId', 'error'],
+  properties: {
+    type: {
+      type: 'string',
+    },
+    requestId: {
+      type: 'string',
+      format: 'uuid',
+    },
+    error: {
+      title: 'AMS response Error Details',
+      type: 'object',
+      additionalProperties: false,
+      required: ['code', 'message'],
+      properties: {
+        code: {
+          type: 'string',
+        },
+        message: {
+          type: 'string',
+        },
+        details: {
+          type: 'object',
+          additionalProperties: true,
+        },
+      },
+    },
+  },
+};
diff --git a/src/platform/generic/data/nodeClasses/processing/LoadResources/getLoadResourceNodeClass.ts b/src/platform/generic/data/nodeClasses/processing/LoadResources/getLoadResourceNodeClass.ts
index 56f257ce7..1274b3b97 100644
--- a/src/platform/generic/data/nodeClasses/processing/LoadResources/getLoadResourceNodeClass.ts
+++ b/src/platform/generic/data/nodeClasses/processing/LoadResources/getLoadResourceNodeClass.ts
@@ -18,6 +18,7 @@ export const getLoadResourceNodeClass = (typeName: LoadResourceTypeKey): Process
     args: [
       { source: 'fixed', value: InteroperationTypeNames[typeName] },
       { source: 'parameter', name: 'ref' },
+      { source: 'parameter', name: 'source' },
     ],
   },
 });
diff --git a/src/platform/generic/data/operations/loadResource.ts b/src/platform/generic/data/operations/loadResource.ts
index b06614cb5..cd9a48314 100644
--- a/src/platform/generic/data/operations/loadResource.ts
+++ b/src/platform/generic/data/operations/loadResource.ts
@@ -6,6 +6,7 @@ export const loadResource: Operation = {
   args: [
     { name: 'resource type', type: InteroperationTypeNames.string },
     { name: 'reference', type: InteroperationTypeNames.string },
+    { name: 'source', type: InteroperationTypeNames.string },
   ],
   outputs: [{ name: 'resource', type: 'auto' }],
 };
diff --git a/src/server/configuration/environment.ts b/src/server/configuration/environment.ts
index 2e0da4362..9860cd9a6 100644
--- a/src/server/configuration/environment.ts
+++ b/src/server/configuration/environment.ts
@@ -199,6 +199,15 @@ function setupFromConfigFiles(instanceIDPrefix: string): Config {
       cdnBaseURL: reader.readOptionalString(configFiles, 'blobStorage', 'cdnBaseURL'),
       urlExpirationTime: reader.readInt(configFiles, 'blobStorage', 'urlExpirationTime'),
     },
+    ams: {
+      enabled: reader.readBoolean(configFiles, 'ams', 'enabled'),
+      requestQueue: reader.readString(configFiles, 'ams', 'requestQueue'),
+      responseExchange: reader.readString(configFiles, 'ams', 'responseExchange'),
+      timeout: reader.readInt(configFiles, 'ams', 'timeout'),
+      fallbackEnabled: reader.readBoolean(configFiles, 'ams', 'fallbackEnabled'),
+      preferProResForOrders: reader.readBoolean(configFiles, 'ams', 'preferProResForOrders'),
+      mp4FallbackForOrders: reader.readBoolean(configFiles, 'ams', 'mp4FallbackForOrders'),
+    },
   };
   return newConfig;
 }
diff --git a/src/server/gateways/ams/index.ts b/src/server/gateways/ams/index.ts
new file mode 100644
index 000000000..19a8e151d
--- /dev/null
+++ b/src/server/gateways/ams/index.ts
@@ -0,0 +1,169 @@
+/* eslint-disable max-lines */
+/**
+ * AMS Gateway - Public API
+ *
+ * This gateway provides high-level functions for ResourceStorage to interact with AMS
+ * without dealing with AMQP/RabbitMQ directly.
+ */
+
+import axios from 'axios';
+import config from '../../configuration/environment';
+import logger from '../../services/logger';
+import { waitForAssetResponse } from './response/resultWaiter';
+import type { AMSAsset, AMSVariation, AMSSearchRequest, VariationSelectionOptions } from './types';
+
+/**
+ * Request asset by ID from AMS
+ */
+export async function requestAssetById(
+  assetId: string
+): Promise<AMSAsset> {
+  const searchRequest: AMSSearchRequest = {
+    assetId,
+  };
+
+  const amsConfig = config.get().ams;
+
+  return waitForAssetResponse(searchRequest, {
+    requestQueue: amsConfig.requestQueue,
+    responseExchange: amsConfig.responseExchange,
+    timeout: amsConfig.timeout,
+  });
+}
+
+/**
+ * Select best variation from asset based on selection criteria
+ * Automatically detects media type by MIME type - prioritizes images first
+ */
+export function selectVariation(
+  asset: AMSAsset,
+  options: VariationSelectionOptions
+): AMSVariation | null {
+  // eslint-disable-next-line unicorn/prevent-abbreviations
+  const { mode = 'preview', scalingFactor, preferProRes = false } = options;
+
+  // Try to find image variations first (more universal)
+  const imageVariations = asset.variations.filter(v => v.mimeType.startsWith('image/'));
+  if (imageVariations.length > 0) {
+    return selectImageVariation(imageVariations, scalingFactor);
+  }
+
+  // If no images, try video variations
+  const videoVariations = asset.variations.filter(v => v.mimeType.startsWith('video/'));
+  if (videoVariations.length > 0) {
+    return selectVideoVariation(videoVariations, mode, scalingFactor, preferProRes);
+  }
+
+  // Fallback: first available variation
+  return asset.variations[0] || null;
+}
+
+/**
+ * Download variation content as Buffer
+ */
+export async function downloadVariationBuffer(
+  url: string,
+  timeoutMs = 30_000
+): Promise<Buffer> {
+  try {
+    const response = await axios.get(url, {
+      responseType: 'arraybuffer',
+      timeout: timeoutMs,
+    });
+
+    return Buffer.from(response.data);
+  } catch (error) {
+    logger.logError(error as Error, {
+      context: 'AMS variation download',
+      url,
+    });
+    throw error;
+  }
+}
+
+// --- Internal variation selection logic ---
+
+function selectImageVariation(
+  variations: AMSVariation[],
+  scalingFactor?: number
+): AMSVariation {
+  if (!scalingFactor || variations.length === 1) {
+    return variations[0];
+  }
+
+  const targetHeight = Math.round(1080 * scalingFactor);
+
+  const withHeight = variations.filter(v => v.height);
+  if (withHeight.length === 0) {
+    return variations[0];
+  }
+
+  // eslint-disable-next-line unicorn/no-array-reduce
+  const closest = withHeight.reduce((best, current) => {
+    const bestDiff = Math.abs((best.height || 0) - targetHeight);
+    const currentDiff = Math.abs((current.height || 0) - targetHeight);
+    return currentDiff < bestDiff ? current : best;
+  });
+
+  return closest;
+}
+
+function selectVideoVariation(
+  variations: AMSVariation[],
+  mode: 'preview' | 'order',
+  scalingFactor?: number,
+  // eslint-disable-next-line unicorn/prevent-abbreviations
+  preferProRes = false
+): AMSVariation {
+  // For orders with ProRes preference - try ProRes first
+  if (mode === 'order' && preferProRes) {
+    // eslint-disable-next-line unicorn/prevent-abbreviations
+    const proResVariations = variations.filter(v =>
+      v.mimeType.includes('video/quicktime')
+    );
+    if (proResVariations.length > 0) {
+      return selectBestVariationByHeight(proResVariations, scalingFactor);
+    }
+  }
+  // Default: prefer MP4 for compatibility
+  const mp4Variations = variations.filter(v =>
+    v.mimeType.includes('video/mp4')
+  );
+  if (mp4Variations.length > 0) {
+    return selectBestVariationByHeight(mp4Variations, scalingFactor);
+  }
+  // Fallback: use any available variation
+  logger.log('warn', 'No MP4 variations found, using first available', {
+    availableMimeTypes: variations.map(v => v.mimeType || 'unknown'),
+  });
+  return selectBestVariationByHeight(variations, scalingFactor);
+}
+
+function selectBestVariationByHeight(
+  variations: AMSVariation[],
+  scalingFactor?: number
+): AMSVariation {
+  if (!scalingFactor || variations.length === 1) {
+    return variations[0];
+  }
+
+  const targetHeight = Math.round(1080 * scalingFactor);
+
+  const withHeight = variations.filter(v => v.height);
+  if (withHeight.length === 0) {
+    // No height info - select variation with highest height if available, otherwise first
+    // eslint-disable-next-line unicorn/no-array-reduce
+    return variations.reduce((best, current) =>
+      (current.height || 0) > (best.height || 0) ? current : best
+    );
+  }
+
+  // eslint-disable-next-line unicorn/no-array-reduce
+  const closest = withHeight.reduce((best, current) => {
+    const bestDiff = Math.abs((best.height || 0) - targetHeight);
+    const currentDiff = Math.abs((current.height || 0) - targetHeight);
+    return currentDiff < bestDiff ? current : best;
+  });
+
+  return closest;
+}
diff --git a/src/server/gateways/ams/internal/requestReply.ts b/src/server/gateways/ams/internal/requestReply.ts
new file mode 100644
index 000000000..39fc4cd56
--- /dev/null
+++ b/src/server/gateways/ams/internal/requestReply.ts
@@ -0,0 +1,219 @@
+/* eslint-disable max-lines */
+import type { Channel, Message } from 'amqplib';
+import { v4 as uuidv4 } from 'uuid';
+import amqpConnection from '../../../mq/connection';
+import logger from '../../../services/logger';
+import type { AMSResponse } from '../../../../types/gateways/ams/response';
+
+interface PendingRequest {
+  resolve: (response: unknown) => void;
+  reject: (error: Error) => void;
+  timeout: ReturnType<typeof setTimeout>;
+  consumerTag: string;
+  replyQueue: string;
+}
+
+interface Config {
+  requestQueue: string;
+  responseExchange?: string | null;
+  timeout: number;
+}
+
+interface PayloadWithRequestId {
+  requestId?: string;
+  type?: string;
+}
+
+export class AMSRequestReplyTransport {
+  private channel: Channel | null = null;
+
+  private pendingRequests = new Map<string, PendingRequest>();
+
+  private initialized = false;
+
+  private config: Config;
+
+  constructor(config: Config) {
+    this.config = config;
+  }
+
+  private async ensureInitialized(): Promise<void> {
+    if (this.initialized) return;
+
+    this.channel = amqpConnection.getDefaultChannel();
+    await this.channel.assertQueue(this.config.requestQueue, { durable: true });
+    this.initialized = true;
+  }
+
+  /* eslint-disable-next-line max-lines-per-function */
+  async sendAndWait(payload: unknown, exchangeOverride?: string, timeoutMs?: number): Promise<unknown> {
+    await this.ensureInitialized();
+
+    if (!this.channel) {
+      throw new Error('Request-reply transport channel not available');
+    }
+
+    const timeout = timeoutMs || this.config.timeout;
+
+    /* eslint-disable-next-line max-lines-per-function */
+    return new Promise((resolve, reject) => {
+      (async (): Promise<void> => {
+        try {
+        const replyQueue = await this.createExclusiveQueue();
+
+        // Use exchange-based reply (Freya compatible)
+        const responseExchange = exchangeOverride || this.config.responseExchange;
+        if (!responseExchange) {
+          throw new Error('Response exchange must be configured for AMS request-reply');
+        }
+
+        const routingKey = uuidv4();
+
+        // Extract requestId from payload for correlation
+        const requestId = (payload as PayloadWithRequestId).requestId || uuidv4();
+
+        const consumerTag = await this.setupReplyConsumer(replyQueue, responseExchange, routingKey, requestId);
+
+        // Complete the payload with proper replyTo (Freya format)
+        const completePayload = {
+          ...(payload as Record<string, unknown>),
+          replyTo: {
+            exchangeName: responseExchange,
+            routingKey,
+          },
+        };
+
+        const timeoutHandle = setTimeout(() => {
+          this.cleanupRequest(requestId, `Request-reply timeout after ${timeout}ms`);
+        }, timeout);
+
+        this.pendingRequests.set(requestId, {
+          resolve,
+          reject,
+          timeout: timeoutHandle,
+          consumerTag,
+          replyQueue,
+        });
+
+        if (!this.channel) {
+          throw new Error('Channel not available for sending message');
+        }
+        await this.channel.sendToQueue(
+          this.config.requestQueue,
+          Buffer.from(JSON.stringify(completePayload)),
+          { correlationId: requestId }
+        );
+
+        logger.log('debug', 'AMS request-reply request sent', {
+          requestId,
+          replyQueue,
+          routingKey,
+          payloadType: typeof payload === 'object' && payload && 'type' in payload
+            ? (payload as PayloadWithRequestId).type
+            : 'unknown'
+        });
+
+        } catch (error) {
+          reject(error instanceof Error ? error : new Error(String(error)));
+        }
+      })();
+    });
+  }
+
+  private async createExclusiveQueue(): Promise<string> {
+    if (!this.channel) throw new Error('Channel not available');
+
+    const reply = await this.channel.assertQueue('', {
+      exclusive: true,
+      autoDelete: true,
+      durable: false,
+    });
+
+    return reply.queue;
+  }
+
+  private async setupReplyConsumer(
+    replyQueue: string, responseExchange: string, routingKey: string, expectedRequestId?: string
+  ): Promise<string> {
+    if (!this.channel) throw new Error('Channel not available');
+
+    // Exchange-based reply (Freya compatible)
+    await this.channel.assertExchange(responseExchange, 'direct', { durable: false });
+    await this.channel.bindQueue(replyQueue, responseExchange, routingKey);
+
+    const response = await this.channel.consume(
+      replyQueue,
+      (message) => {
+        if (message) {
+          this.handleResponse(message, expectedRequestId);
+          if (this.channel) {
+            this.channel.ack(message);
+          }
+        }
+      },
+      { noAck: false }
+    );
+
+    return response.consumerTag;
+  }
+
+  private handleResponse(message: Message, expectedRequestId?: string): void {
+    try {
+      const response = JSON.parse(message.content.toString()) as AMSResponse;
+      if (!response || typeof response !== 'object') {
+        logger.log('warn', 'Invalid AMS request-reply response format', { expectedRequestId });
+        return;
+      }
+      if (expectedRequestId && response.requestId !== expectedRequestId) {
+        logger.log('warn', 'AMS request-reply response requestId mismatch', {
+          expected: expectedRequestId,
+          received: response.requestId,
+        });
+        return;
+      }
+      const pending = this.pendingRequests.get(response.requestId);
+      if (pending) {
+        this.cleanupRequest(response.requestId);
+        pending.resolve(response);
+        logger.log('debug', 'AMS request-reply response received', {
+          requestId: response.requestId,
+          hasPayload: 'payload' in response,
+          hasError: 'error' in response,
+        });
+      }
+    } catch (error) {
+      logger.logError(error as Error, {
+        context: 'AMS request-reply response parsing', expectedRequestId
+      });
+    }
+  }
+
+  private async cleanupRequest(requestId: string, errorMessage?: string): Promise<void> {
+    const pending = this.pendingRequests.get(requestId);
+    if (!pending) return;
+
+    try {
+      clearTimeout(pending.timeout);
+
+      if (this.channel) {
+        await this.channel.cancel(pending.consumerTag);
+        await this.channel.deleteQueue(pending.replyQueue);
+      }
+
+      this.pendingRequests.delete(requestId);
+
+      if (errorMessage) {
+        pending.reject(new Error(errorMessage));
+      }
+    } catch (error) {
+      logger.logError(error as Error, {
+        context: 'AMS request-reply request cleanup',
+        requestId
+      });
+
+      if (errorMessage) {
+        pending.reject(new Error(errorMessage));
+      }
+    }
+  }
+}
diff --git a/src/server/gateways/ams/request/requestHandler.ts b/src/server/gateways/ams/request/requestHandler.ts
new file mode 100644
index 000000000..20223712f
--- /dev/null
+++ b/src/server/gateways/ams/request/requestHandler.ts
@@ -0,0 +1,41 @@
+import { v4 as uuidv4 } from 'uuid';
+import type { AMSSearchRequest } from '../types';
+import logger from '../../../services/logger';
+
+/* eslint-disable-next-line max-lines-per-function */
+export async function sendAssetRequest(
+  searchRequest: AMSSearchRequest,
+  config: {
+    requestQueue: string;
+    responseExchange?: string | null;
+  },
+  requestReplyTransport: { sendAndWait: (payload: unknown, replyQueue: string, timeoutMs?: number) => Promise<unknown> }
+): Promise<unknown> {
+  const requestId = uuidv4();
+
+  const basePayload = {
+    type: 'searchAssets' as const,
+    requestId,
+    payload: {
+      offset: 0,
+      limit: 1,
+      query: {
+        field: 'id' as const,
+        operator: 'equals' as const,
+        value: searchRequest.assetId,
+      },
+    },
+  };
+
+  logger.log('info', 'Sending AMS asset request', {
+    assetId: searchRequest.assetId,
+    requestId,
+  });
+
+  // Request-reply transport will complete the payload with proper replyTo
+  return requestReplyTransport.sendAndWait(
+    basePayload,
+    config.responseExchange || '', // Pass exchange config to transport
+    undefined
+  );
+}
diff --git a/src/server/gateways/ams/response/parseResultMessage.ts b/src/server/gateways/ams/response/parseResultMessage.ts
new file mode 100644
index 000000000..157feb2ce
--- /dev/null
+++ b/src/server/gateways/ams/response/parseResultMessage.ts
@@ -0,0 +1,106 @@
+import Ajv from 'ajv';
+import { amsResponseSchema, amsResponseSuccessSchema, amsResponseErrorSchema }
+  from '../../../../jsonSchemas/gateways/ams/response';
+import type { AMSResponse, AMSResponseSuccess, AMSResponseError } from '../types';
+import logger from '../../../services/logger';
+
+// Local AJV instance with formats needed for AMS validation
+const ajv = new Ajv({ formats: { uuid: true, uri: true } });
+
+const validateResponse = ajv.compile(amsResponseSchema);
+const validateSuccessResponse = ajv.compile(amsResponseSuccessSchema);
+const validateErrorResponse = ajv.compile(amsResponseErrorSchema);
+
+function validateBasicResponse(rawResponse: unknown): AMSResponse {
+  // Basic type check
+  if (!rawResponse || typeof rawResponse !== 'object') {
+    throw new Error('Invalid AMS response: not an object');
+  }
+
+  // Validate against union schema first
+  if (!validateResponse(rawResponse)) {
+    const errors = validateResponse.errors || [];
+    logger.logError(new Error('AMS response validation failed'), {
+      context: 'AMS response validation',
+      errors: errors.map(error => ({
+        instancePath: error.instancePath,
+        message: error.message,
+        params: error.params,
+      })),
+      rawResponse: JSON.stringify(rawResponse),
+    });
+    throw new Error(`Invalid AMS response: ${errors[0]?.message || 'Unknown validation error'}`);
+  }
+
+  return rawResponse as AMSResponse;
+}
+
+function parseSuccessResponse(response: AMSResponse): { ok: true; data: AMSResponseSuccess } {
+  if (!validateSuccessResponse(response)) {
+    const errors = validateSuccessResponse.errors || [];
+    throw new Error(`Invalid AMS success response: ${errors[0]?.message || 'Unknown validation error'}`);
+  }
+  const successResponse = response as AMSResponseSuccess;
+  // Additional business logic validation for success responses
+  if (!successResponse.payload.asset) {
+    throw new Error('AMS success response missing asset data');
+  }
+  if (!successResponse.payload.asset.variations || successResponse.payload.asset.variations.length === 0) {
+    throw new Error('AMS asset has no variations available');
+  }
+  // Validate variations have required fields
+  for (const variation of successResponse.payload.asset.variations) {
+    if (!variation.url || !variation.mimeType) {
+      throw new Error(
+        `Invalid variation: missing required fields (url: ${!!variation.url}, mimeType: ${!!variation.mimeType})`
+      );
+    }
+  }
+  logger.log('debug', 'AMS success response parsed', {
+    requestId: successResponse.requestId,
+    assetId: successResponse.payload.asset.id,
+    variationsCount: successResponse.payload.asset.variations.length,
+  });
+  return { ok: true, data: successResponse };
+}
+
+function parseErrorResponse(response: AMSResponse): { ok: false; error: AMSResponseError } {
+  if (!validateErrorResponse(response)) {
+    const errors = validateErrorResponse.errors || [];
+    throw new Error(`Invalid AMS error response: ${errors[0]?.message || 'Unknown validation error'}`);
+  }
+
+  const errorResponse = response as AMSResponseError;
+
+  logger.log('warn', 'AMS error response parsed', {
+    requestId: errorResponse.requestId,
+    errorCode: errorResponse.error.code,
+    errorMessage: errorResponse.error.message,
+  });
+
+  return { ok: false, error: errorResponse };
+}
+
+export function parseAMSResponse(rawResponse: unknown):
+  { ok: true; data: AMSResponseSuccess } | { ok: false; error: AMSResponseError } {
+  const response = validateBasicResponse(rawResponse);
+
+  // Determine response type by checking for payload or error
+  if ('payload' in response && response.payload) {
+    return parseSuccessResponse(response);
+  }
+
+  if ('error' in response && response.error) {
+    return parseErrorResponse(response);
+  }
+
+  throw new Error('AMS response must contain either payload or error');
+}
+
+export function isAMSSuccessResponse(response: { ok: boolean }): response is { ok: true; data: AMSResponseSuccess } {
+  return response.ok === true;
+}
+
+export function isAMSErrorResponse(response: { ok: boolean }): response is { ok: false; error: AMSResponseError } {
+  return response.ok === false;
+}
diff --git a/src/server/gateways/ams/response/resultWaiter.ts b/src/server/gateways/ams/response/resultWaiter.ts
new file mode 100644
index 000000000..ca0a9109a
--- /dev/null
+++ b/src/server/gateways/ams/response/resultWaiter.ts
@@ -0,0 +1,75 @@
+import { AMSRequestReplyTransport } from '../internal/requestReply';
+import { sendAssetRequest } from '../request/requestHandler';
+import logger from '../../../services/logger';
+import type { AMSSearchRequest, AMSAsset } from '../types';
+import { parseAMSResponse, isAMSSuccessResponse } from './parseResultMessage';
+
+interface WaiterConfig {
+  requestQueue: string;
+  responseExchange?: string | null;
+  timeout: number;
+}
+
+let requestReplyTransport: AMSRequestReplyTransport | null = null;
+
+function getRequestReplyTransport(config: WaiterConfig): AMSRequestReplyTransport {
+  if (!requestReplyTransport) {
+    requestReplyTransport = new AMSRequestReplyTransport({
+      requestQueue: config.requestQueue,
+      responseExchange: config.responseExchange,
+      timeout: config.timeout,
+    });
+  }
+  return requestReplyTransport;
+}
+
+/* eslint-disable-next-line max-lines-per-function */
+export async function waitForAssetResponse(
+  searchRequest: AMSSearchRequest,
+  config: WaiterConfig
+): Promise<AMSAsset> {
+  const transport = getRequestReplyTransport(config);
+
+  try {
+    // Send request and wait for response
+    const rawResponse = await sendAssetRequest(
+      searchRequest,
+      {
+        requestQueue: config.requestQueue,
+        responseExchange: config.responseExchange,
+      },
+      transport
+    );
+
+    // Parse and validate response
+    const parsedResponse = parseAMSResponse(rawResponse);
+
+    // Check if request was successful
+    if (!isAMSSuccessResponse(parsedResponse)) {
+      const errorMessage = parsedResponse.error.error.message || 'AMS request failed with no error message';
+      logger.log('error', 'AMS asset request failed', {
+        assetId: searchRequest.assetId,
+        requestId: parsedResponse.error.requestId,
+        errorCode: parsedResponse.error.error.code,
+        error: errorMessage,
+      });
+      throw new Error(`AMS asset request failed: ${errorMessage}`);
+    }
+
+    logger.log('info', 'AMS asset request completed successfully', {
+      assetId: searchRequest.assetId,
+      requestId: parsedResponse.data.requestId,
+      assetType: parsedResponse.data.payload.asset.type,
+      variationsCount: parsedResponse.data.payload.asset.variations.length,
+    });
+
+    return parsedResponse.data.payload.asset;
+
+  } catch (error) {
+    logger.logError(error as Error, {
+      context: 'AMS asset request',
+      assetId: searchRequest.assetId,
+    });
+    throw error;
+  }
+}
diff --git a/src/server/gateways/ams/types/index.ts b/src/server/gateways/ams/types/index.ts
new file mode 100644
index 000000000..b56dbf696
--- /dev/null
+++ b/src/server/gateways/ams/types/index.ts
@@ -0,0 +1,43 @@
+/**
+ * AMS Gateway Types - Re-exports of generated types and internal types
+ */
+// Convenience type aliases for gateway internal use
+import type { AMSResponseAsset, AMSResponseVariation } from '../../../../types/gateways/ams/response';
+
+export type AMSAsset = AMSResponseAsset;
+export type AMSVariation = AMSResponseVariation;
+
+// Re-export generated types
+export type {
+  AMSRequest,
+  AMSRequestReplyTo,
+  AMSRequestPayload,
+  AMSRequestQuery
+} from '../../../../types/gateways/ams/request';
+
+export type {
+  AMSResponse,
+  AMSResponseAsset,
+  AMSResponseVariation
+} from '../../../../types/gateways/ams/response';
+
+export type {
+  AMSResponseSuccess
+} from '../../../../types/gateways/ams/responseSuccess';
+
+export type {
+  AMSResponseError,
+  AMSResponseErrorDetails
+} from '../../../../types/gateways/ams/responseError';
+
+
+// Internal gateway types
+export interface AMSSearchRequest {
+  assetId: string;
+}
+
+export interface VariationSelectionOptions {
+  mode?: 'preview' | 'order';
+  scalingFactor?: number;
+  preferProRes?: boolean;
+}
diff --git a/src/server/services/resources/storage.ts b/src/server/services/resources/storage.ts
index 89799039f..3b26a16c1 100644
--- a/src/server/services/resources/storage.ts
+++ b/src/server/services/resources/storage.ts
@@ -1,3 +1,4 @@
+/* eslint-disable max-lines */
 import type { Sharp } from 'sharp';
 import sharp from 'sharp';
 import type { ResourceUrls } from 'platform/types/Services/ResourceStorage';
@@ -6,7 +7,10 @@ import type { InteroperationType } from 'types/InteroperationTypes';
 import type { RuntimeValue, ServerImageSequence } from 'server/types/RuntimeValue';
 import { InteroperationTypeNames } from '../../../types/InteroperationTypes/index';
 import { isImageType, isImageSequenceType } from '../../../types/InteroperationTypes/Predicates';
-import { isValidAMSResourceReference } from '../../../types/InteroperationTypes/ValuePredicates';
+import {
+  isValidAMSResourceReference,
+  isValidGeneratorResourceReference
+} from '../../../types/InteroperationTypes/ValuePredicates';
 import { scaleAndRound } from '../../../graphics/common/pixels/scale';
 import blobStorageClient from '../../azure/blobStorageClient';
 import config from '../../configuration/environment';
@@ -57,11 +61,25 @@ async function get(
   type: InteroperationType,
   scalingFactor?: number,
 ): Promise<RuntimeValue | null> {
-  if (isValidAMSResourceReference(resourceReference)) throw new Error('AMS resource handling is not implemented');
-
   if (!supportedTypes.includes(type.type))
     throw new Error(`Resource types other than ${supportedTypes.join(', ')} are not supported, got '${type.type}'`);
 
+  if (isValidGeneratorResourceReference(resourceReference)) {
+    return getGeneratorResource(resourceReference, type, scalingFactor);
+  }
+
+  if (isValidAMSResourceReference(resourceReference)) {
+    return getAMSResource(resourceReference, type, scalingFactor);
+  }
+
+  throw new Error(`Invalid resource reference: ${JSON.stringify(resourceReference)}`);
+}
+
+async function getGeneratorResource(
+  resourceReference: GeneratorResourceReference,
+  type: InteroperationType,
+  scalingFactor?: number,
+): Promise<RuntimeValue | null> {
   if (isImageSequenceType(type)) {
     const imageSequence: ServerImageSequence = { frames: [], source: resourceReference.resourceRef, scalingFactor };
     return imageSequence;
@@ -79,40 +97,122 @@ async function get(
   return storedResource;
 }
 
+async function getAMSResource(
+  resourceReference: { ams: string },
+  type: InteroperationType,
+  scalingFactor?: number
+): Promise<RuntimeValue | null> {
+  if (type.type === 'imageSequence') {
+    throw new Error('AMS image sequences not supported yet');
+  }
+
+  if (!config.get().ams?.enabled) {
+    if (config.get().ams?.fallbackEnabled) {
+      logger.log('warn', `AMS disabled, attempting fallback for ${resourceReference.ams}`);
+      return tryAMSFallback(resourceReference.ams);
+    }
+    return null;
+  }
+
+  try {
+    return await getAMSResourceViaRabbitMQ(
+      resourceReference.ams,
+      scalingFactor
+    );
+  } catch (error) {
+    throw new Error(`AMS resource ${resourceReference.ams} failed: ${(error as Error).message}`);
+  }
+}
+
+async function getAMSResourceViaRabbitMQ(
+  assetId: string,
+  scalingFactor?: number
+): Promise<RuntimeValue | null> {
+  const amsGateway = (await import('../../gateways/ams'));
+  try {
+    // Request asset from AMS
+    const asset = await amsGateway.requestAssetById(assetId);
+    // Select best variation (by MIME)
+    const variation = amsGateway.selectVariation(asset, {
+      mode: 'preview',
+      scalingFactor,
+      preferProRes: config.get().ams.preferProResForOrders,
+    });
+    if (!variation) {
+      throw new Error(`No suitable variation found for asset ${assetId}`);
+    }
+    logger.log('info', `AMS asset variation selected`, {
+      assetId,
+      variationUrl: variation.url,
+      mimeType: variation.mimeType,
+    });
+    // Download variation content
+    const buffer = await amsGateway.downloadVariationBuffer(variation.url);
+    return await ensureImageProperties(buffer);
+  } catch (error) {
+    throw new Error(`AMS asset ${assetId} failed: ${(error as Error).message}`);
+  }
+}
+
+async function tryAMSFallback(assetId: string): Promise<RuntimeValue | null> {
+  logger.log('info', `AMS fallback attempted for: ${assetId}`);
+  return null;
+}
+
 async function getRaw(resourceReference: ResourceReference): Promise<Buffer | null> {
-  if (isValidAMSResourceReference(resourceReference)) throw new Error('AMS resource handling is not implemented');
-  const storedResource = await blobStorageClient.get(resourceReference.resourceRef);
-  if (!storedResource) return null;
-  return storedResource;
+  if (isValidGeneratorResourceReference(resourceReference)) {
+    const storedResource = await blobStorageClient.get(resourceReference.resourceRef);
+    if (!storedResource) return null;
+    return storedResource;
+  }
+
+  if (isValidAMSResourceReference(resourceReference)) {
+    throw new Error('AMS raw resource handling not implemented yet');
+  }
+
+  throw new Error(`Invalid resource reference: ${JSON.stringify(resourceReference)}`);
 }
 
 async function mapToURLs(resourceReference: ResourceReference): Promise<ResourceUrls> {
-  if (isValidAMSResourceReference(resourceReference)) throw new Error('AMS resource handling is not implemented');
-  const allRefs = getAllRefs(resourceReference);
-
-  const resourceReferencesWithUrl = await Promise.all(
-    allRefs.map(async (ref) => ({
-      ...ref,
-      url: await url(ref),
-    })),
-  );
-
-  return Object.fromEntries(
-    resourceReferencesWithUrl.map((resourceWithUrl: ResourceWithUrl) => [
-      resourceWithUrl.resourceRef,
-      resourceWithUrl.url,
-    ]),
-  );
+  if (isValidGeneratorResourceReference(resourceReference)) {
+    const allRefs = getAllRefs(resourceReference);
+
+    const resourceReferencesWithUrl = await Promise.all(
+      allRefs.map(async (ref) => ({
+        ...ref,
+        url: await url(ref),
+      })),
+    );
+
+    return Object.fromEntries(
+      resourceReferencesWithUrl.map((resourceWithUrl: ResourceWithUrl) => [
+        resourceWithUrl.resourceRef,
+        resourceWithUrl.url,
+      ]),
+    );
+  }
+
+  if (isValidAMSResourceReference(resourceReference)) {
+    throw new Error('AMS URL mapping not implemented yet');
+  }
+
+  throw new Error(`Invalid resource reference: ${JSON.stringify(resourceReference)}`);
 }
 
 async function url(resourceReference: ResourceReference): Promise<string> {
-  if (isValidAMSResourceReference(resourceReference)) throw new Error('AMS resource handling is not implemented');
+  if (isValidGeneratorResourceReference(resourceReference)) {
+    if (config.get().dev.serveResources) {
+      return `/resources/${resourceReference.resourceRef}`;
+    }
+
+    return blobStorageClient.presignedUrl(resourceReference.resourceRef, { useCDN: true, useCache: true });
+  }
 
-  if (config.get().dev.serveResources) {
-    return `/resources/${resourceReference.resourceRef}`;
+  if (isValidAMSResourceReference(resourceReference)) {
+    throw new Error('AMS URL generation not implemented yet');
   }
 
-  return blobStorageClient.presignedUrl(resourceReference.resourceRef, { useCDN: true, useCache: true });
+  throw new Error(`Invalid resource reference: ${JSON.stringify(resourceReference)}`);
 }
 
 async function resizeImage(
diff --git a/src/server/tools/build-api/exportSchemas/exports/ams.yaml b/src/server/tools/build-api/exportSchemas/exports/ams.yaml
new file mode 100644
index 000000000..d6726f775
--- /dev/null
+++ b/src/server/tools/build-api/exportSchemas/exports/ams.yaml
@@ -0,0 +1,15 @@
+- srcFile: remote/ams/request.yaml
+  dstFile: gateways/ams/request.ts
+  schemas:
+    - name: amsRequest
+      type: { name: AMSRequest, importFrom: types/gateways/ams/request }
+
+- srcFile: remote/ams/response.yaml
+  dstFile: gateways/ams/response.ts
+  schemas:
+    - name: amsResponse
+      type: { name: AMSResponse, importFrom: types/gateways/ams/response }
+    - name: amsResponseSuccess
+      type: { name: AMSResponseSuccess, importFrom: types/gateways/ams/responseSuccess }
+    - name: amsResponseError
+      type: { name: AMSResponseError, importFrom: types/gateways/ams/responseError }
\ No newline at end of file
diff --git a/src/server/tools/build-api/types/exports/ams.yaml b/src/server/tools/build-api/types/exports/ams.yaml
new file mode 100644
index 000000000..612fa8d67
--- /dev/null
+++ b/src/server/tools/build-api/types/exports/ams.yaml
@@ -0,0 +1,15 @@
+- srcFile: remote/ams/request.yaml
+  rootProperty: amsRequest
+  dstFile: src/types/gateways/ams/request.ts
+
+- srcFile: remote/ams/response.yaml
+  rootProperty: amsResponse
+  dstFile: src/types/gateways/ams/response.ts
+
+- srcFile: remote/ams/response.yaml
+  rootProperty: amsResponseSuccess
+  dstFile: src/types/gateways/ams/responseSuccess.ts
+
+- srcFile: remote/ams/response.yaml
+  rootProperty: amsResponseError
+  dstFile: src/types/gateways/ams/responseError.ts
\ No newline at end of file
diff --git a/src/server/types/Config.ts b/src/server/types/Config.ts
index 2748e581d..f721828af 100644
--- a/src/server/types/Config.ts
+++ b/src/server/types/Config.ts
@@ -1,3 +1,4 @@
+/* eslint-disable max-lines */
 import type { JobConfig } from 'server/azure/batch';
 
 export type Config = {
@@ -142,4 +143,13 @@ export type Config = {
     urlExpirationTime: number;
     cdnBaseURL: string | null;
   };
+  ams: {
+    enabled: boolean;
+    requestQueue: string;
+    responseExchange: string;
+    timeout: number;
+    fallbackEnabled: boolean;
+    preferProResForOrders: boolean;
+    mp4FallbackForOrders: boolean;
+  };
 };
diff --git a/src/server/types/OperationServices/index.ts b/src/server/types/OperationServices/index.ts
index 9a7156217..c496b054b 100644
--- a/src/server/types/OperationServices/index.ts
+++ b/src/server/types/OperationServices/index.ts
@@ -13,6 +13,7 @@ import type { RemoteRequestService } from './RemoteRequests';
 import type { VideoProgress } from './VideoProgress';
 import type { ProductSelectionService } from './ProductSelection';
 
+
 export type OperationServices = {
   inputValues: InputValues;
   dimensions: Dimensions;
diff --git a/src/types/gateways/ams/request.ts b/src/types/gateways/ams/request.ts
new file mode 100644
index 000000000..827cdd99a
--- /dev/null
+++ b/src/types/gateways/ams/request.ts
@@ -0,0 +1,29 @@
+/* eslint-disable unicorn/no-abusive-eslint-disable */
+/* eslint-disable */
+/*
+  WARNING!
+  This schema was automatically built from "remote/ams/request.yaml".
+  Please do not edit it manually.
+  Update `documentation/api/schemas` and run `npm run build-json-schema-types`.
+*/
+
+export type AMSRequest = {
+  type: "searchAssets";
+  requestId: string;
+  replyTo: AMSRequestReplyTo;
+  payload: AMSRequestPayload;
+}
+export type AMSRequestReplyTo = {
+  exchangeName: string;
+  routingKey: string;
+}
+export type AMSRequestPayload = {
+  offset: number;
+  limit: number;
+  query: AMSRequestQuery;
+}
+export type AMSRequestQuery = {
+  field: "id";
+  operator: "equals";
+  value: string;
+}
diff --git a/src/types/gateways/ams/response.ts b/src/types/gateways/ams/response.ts
new file mode 100644
index 000000000..4a4e9ff2d
--- /dev/null
+++ b/src/types/gateways/ams/response.ts
@@ -0,0 +1,44 @@
+/* eslint-disable unicorn/no-abusive-eslint-disable */
+/* eslint-disable */
+/*
+  WARNING!
+  This schema was automatically built from "remote/ams/response.yaml".
+  Please do not edit it manually.
+  Update `documentation/api/schemas` and run `npm run build-json-schema-types`.
+*/
+
+export type AMSResponse = AMSResponseSuccess | AMSResponseError;
+
+export type AMSResponseSuccess = {
+  type: string;
+  requestId: string;
+  payload: AMSResponsePayload;
+}
+export type AMSResponsePayload = {
+  asset: AMSResponseAsset;
+}
+export type AMSResponseAsset = {
+  id: string;
+  type: "image" | "video";
+  variations: AMSResponseVariation[];
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+export type AMSResponseVariation = {
+  url: string;
+  height: number;
+  mimeType: string;
+}
+export type AMSResponseError = {
+  type: string;
+  requestId: string;
+  error: AMSResponseErrorDetails;
+}
+export type AMSResponseErrorDetails = {
+  code: string;
+  message: string;
+  details?: {
+    [k: string]: unknown;
+  };
+}
diff --git a/src/types/gateways/ams/responseError.ts b/src/types/gateways/ams/responseError.ts
new file mode 100644
index 000000000..e6b98ff67
--- /dev/null
+++ b/src/types/gateways/ams/responseError.ts
@@ -0,0 +1,21 @@
+/* eslint-disable unicorn/no-abusive-eslint-disable */
+/* eslint-disable */
+/*
+  WARNING!
+  This schema was automatically built from "remote/ams/response.yaml".
+  Please do not edit it manually.
+  Update `documentation/api/schemas` and run `npm run build-json-schema-types`.
+*/
+
+export type AMSResponseError = {
+  type: string;
+  requestId: string;
+  error: AMSResponseErrorDetails;
+}
+export type AMSResponseErrorDetails = {
+  code: string;
+  message: string;
+  details?: {
+    [k: string]: unknown;
+  };
+}
diff --git a/src/types/gateways/ams/responseSuccess.ts b/src/types/gateways/ams/responseSuccess.ts
new file mode 100644
index 000000000..9f21b7eff
--- /dev/null
+++ b/src/types/gateways/ams/responseSuccess.ts
@@ -0,0 +1,30 @@
+/* eslint-disable unicorn/no-abusive-eslint-disable */
+/* eslint-disable */
+/*
+  WARNING!
+  This schema was automatically built from "remote/ams/response.yaml".
+  Please do not edit it manually.
+  Update `documentation/api/schemas` and run `npm run build-json-schema-types`.
+*/
+
+export type AMSResponseSuccess = {
+  type: string;
+  requestId: string;
+  payload: AMSResponsePayload;
+}
+export type AMSResponsePayload = {
+  asset: AMSResponseAsset;
+}
+export type AMSResponseAsset = {
+  id: string;
+  type: "image" | "video";
+  variations: AMSResponseVariation[];
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+export type AMSResponseVariation = {
+  url: string;
+  height: number;
+  mimeType: string;
+}
diff --git a/test/fixtures/ams/sample-image-small.png b/test/fixtures/ams/sample-image-small.png
new file mode 100644
index 000000000..9d1fcc43a
Binary files /dev/null and b/test/fixtures/ams/sample-image-small.png differ
diff --git a/test/fixtures/ams/sample-image.png b/test/fixtures/ams/sample-image.png
new file mode 100644
index 000000000..7926b5a7c
Binary files /dev/null and b/test/fixtures/ams/sample-image.png differ
diff --git a/test/fixtures/ams/sample-video.mp4 b/test/fixtures/ams/sample-video.mp4
new file mode 100644
index 000000000..b11552f9c
Binary files /dev/null and b/test/fixtures/ams/sample-video.mp4 differ
diff --git a/test/server/integration/ams.test.ts b/test/server/integration/ams.test.ts
new file mode 100644
index 000000000..34811d5fb
--- /dev/null
+++ b/test/server/integration/ams.test.ts
@@ -0,0 +1,205 @@
+/* eslint-disable max-lines, @typescript-eslint/no-explicit-any, unicorn/consistent-function-scoping */
+import { describe, test, expect, beforeAll, afterAll } from 'vitest';
+import app from '../../../src/server/app/index';
+import environmentConfig from '../../../src/server/configuration/environment';
+import { setupFakeAMS } from '../../support/server/fakeRemotes/fakeAMS';
+import * as amsGateway from '../../../src/server/gateways/ams/index';
+
+/* eslint-disable-next-line max-lines-per-function */
+describe('AMS RabbitMQ Integration Tests', () => {
+  beforeAll(async () => {
+    // Initialize configuration first
+    await environmentConfig.setup();
+
+    // Start the application with web services
+    await app.start({ runWeb: true });
+
+    // Wait for all services including RabbitMQ to initialize
+    await new Promise<void>(resolve => { setTimeout(() => resolve(), 2000); });
+
+    // Setup fake AMS after everything is ready
+    setupFakeAMS();
+
+    // Give fake AMS time to setup its queue listener
+    await new Promise<void>(resolve => { setTimeout(() => resolve(), 4000); });
+  }, 90_000); // Long timeout for full setup
+
+  afterAll(async () => {
+    await app.stop();
+  }, 30_000);
+
+  /* eslint-disable-next-line max-lines-per-function */
+  describe('End-to-End AMS Integration', () => {
+    test('should successfully request image asset through RabbitMQ', async () => {
+      // Test full request-reply cycle through RabbitMQ
+      const asset = await amsGateway.requestAssetById('image-asset-001');
+
+      expect(asset).toBeDefined();
+      expect(asset.id).toBe('image-asset-001');
+      expect(asset.variations).toBeDefined();
+      expect(asset.variations.length).toBeGreaterThan(0);
+
+      // Verify structure matches new wire contract
+      const variation = asset.variations[0];
+      expect(variation.url).toBeDefined();
+      expect(variation.mimeType).toBeDefined();
+      expect(variation.height).toBeDefined();
+    }, 30_000);
+
+    test('should successfully request video asset through RabbitMQ', async () => {
+      const asset = await amsGateway.requestAssetById('video-asset-001');
+
+      expect(asset).toBeDefined();
+      expect(asset.id).toBe('video-asset-001');
+      expect(asset.variations).toBeDefined();
+      expect(asset.variations.length).toBeGreaterThan(0);
+
+      // Check video variation has video mimeType
+      const variation = asset.variations[0];
+      expect(variation.mimeType).toMatch(/^video\//);
+    }, 30_000);
+
+    test('should handle asset not found error through RabbitMQ', async () => {
+      try {
+        await amsGateway.requestAssetById('error-asset-001');
+
+        // Should not reach here
+        expect(false).toBe(true);
+      } catch (error) {
+        expect(error).toBeDefined();
+        expect(error.message).toContain('not found');
+      }
+    }, 30_000);
+  });
+
+  describe('Wire Contract Validation', () => {
+    test('should use exchange-based replies through RabbitMQ', async () => {
+      // This test verifies that exchange-based communication works
+      const asset = await amsGateway.requestAssetById('image-asset-001');
+
+      expect(asset).toBeDefined();
+      // If we get a response, exchange-based replies are working
+      expect(asset.id).toBe('image-asset-001');
+    }, 30_000);
+
+    test('should handle new response format without success field', async () => {
+      // Test that new payload/error format works through RabbitMQ
+      const asset = await amsGateway.requestAssetById('image-asset-001');
+
+      expect(asset).toBeDefined();
+      expect(asset.variations).toBeDefined();
+
+    }, 30_000);
+  });
+
+  describe('Asset Download Integration', () => {
+    test('should download asset variation buffer', async () => {
+      const asset = await amsGateway.requestAssetById('image-asset-001');
+
+      const variation = asset.variations[0];
+      const buffer = await amsGateway.downloadVariationBuffer(variation.url);
+
+      expect(buffer).toBeInstanceOf(Buffer);
+      expect(buffer.length).toBeGreaterThan(0);
+    }, 30_000);
+  });
+
+  /**
+   * Helper function to create mock services for Load Resource operation tests.
+   *
+   * We use direct operation testing instead of testBench because:
+   * 1. testBench expects full directory structure (samples/, binaries/, etc.) which we don't want to commit
+   * 2. testBench loads all sample files into memory, which is overkill for our targeted tests
+   * 3. Direct testing gives us precise control over what we're testing (Load Resource logic)
+   *
+   * Our approach tests the actual Load Resource operation function with minimal mocks,
+   * ensuring we cover the core functionality (3-arg signature, source routing) without
+   * the overhead of the full testBench system.
+   */
+  async function createMockServices(includeResourceStorage = false): Promise<any> {
+    const mockServices: any = {
+      scheduler: {
+        run: async (fn: any) => fn(includeResourceStorage ? mockServices : {})
+      }
+    };
+
+    if (includeResourceStorage) {
+      const ResourceStorage = await import('../../../src/server/services/resources/storage');
+      mockServices.resourceStorage = ResourceStorage.default;
+    }
+
+    return mockServices;
+  }
+
+  const mockConfig = {
+    scalingFactor: 1,
+    outputs: [{ name: 'resource' }],
+    quality: 'normal'
+  } as any;
+
+  /* eslint-disable-next-line max-lines-per-function */
+  describe('Load Resource Operation Integration', () => {
+    test('should execute Load Resource operation with 3 arguments and AMS source', async () => {
+      // Import Load Resource implementation directly
+      const loadResourceImpl = await import('../../../src/graphics/server/operations/loadResource');
+      const mockServices = await createMockServices(true);
+
+      // Test Load Resource with 3 arguments: [resourceType, resourceRef, source]
+      const result = await loadResourceImpl.default.fn(mockServices, mockConfig, [
+        'image',                    // resourceType
+        'image-asset-001',         // resourceRef (assetId for AMS)
+        'ams'                      // source - triggers AMS routing
+      ], {} as any);
+
+      expect(result.outputs).toBeDefined();
+      expect(result.outputs.length).toBeGreaterThan(0);
+
+      // The result should be a Buffer (binary data)
+      const output = result.outputs[0];
+      expect(output).toBeDefined();
+      expect(output.value).toBeInstanceOf(Buffer);
+      expect((output.value as Buffer).length).toBeGreaterThan(0);
+    }, 60_000);
+
+    test('should route to generator when source is not ams', async () => {
+      // Import Load Resource implementation directly
+      const loadResourceImpl = await import('../../../src/graphics/server/operations/loadResource');
+      const mockServices = await createMockServices(true);
+
+      try {
+        const result = await loadResourceImpl.default.fn(mockServices, mockConfig, [
+          'image',
+          'some-generator-resource',
+          'generator'  // Should route to generator, not AMS
+        ], {} as any);
+
+        // If this succeeds, generator routing works
+        expect(result).toBeDefined();
+      } catch (error) {
+        // Expected to fail, but error should be about resource not found, not routing
+        expect(error.message).not.toContain('Invalid source');
+        expect(error.message).not.toContain('Unknown source');
+      }
+    }, 30_000);
+
+    test('should handle Load Resource with 2 arguments (backward compatibility)', async () => {
+      // Import Load Resource implementation directly
+      const loadResourceImpl = await import('../../../src/graphics/server/operations/loadResource');
+      const mockServices = await createMockServices(false); // No ResourceStorage needed for this test
+
+      try {
+        // Test that 2-argument calls are rejected (we require 3 args now)
+        await loadResourceImpl.default.fn(mockServices, mockConfig, [
+          'image',
+          'some-resource'  // Only 2 args - should be rejected
+        ], {} as any);
+
+        // Should not reach here - 2 args should be rejected
+        expect(true).toBe(false);
+      } catch (error) {
+        // Should fail with "Missing arguments" since we require exactly 3 args
+        expect(error.message).toContain('Missing arguments');
+      }
+    }, 30_000);
+  });
+});
diff --git a/test/support/server/fakeRemotes/fakeAMS.ts b/test/support/server/fakeRemotes/fakeAMS.ts
new file mode 100644
index 000000000..14b367458
--- /dev/null
+++ b/test/support/server/fakeRemotes/fakeAMS.ts
@@ -0,0 +1,221 @@
+// eslint-disable-line unicorn/filename-case
+/* eslint-disable camelcase, max-lines, no-console */
+import fs from 'node:fs';
+import path from 'node:path';
+import type { Request, Response } from 'express';
+import Ajv from 'ajv';
+import yaml from 'js-yaml';
+import webApp from '../../../../src/server/http/index';
+import AMQPConnection from '../../../../src/server/mq/connection';
+import { publishAMQPMessage } from '../../../../src/server/mq/publish';
+import { openAPIIgnoreRegexString, openAPIIgnoreList } from '../../../../src/server/http/utils/openAPI';
+
+type AMSRequest = {
+  type: string;
+  requestId: string;
+  replyTo: {
+    exchangeName: string;
+    routingKey: string;
+  };
+  payload: {
+    offset: number;
+    limit: number;
+    query: {
+      field: string;
+      operator: string;
+      value: string;
+    };
+  };
+};
+
+type MockAssetData = {
+  [assetId: string]: {
+    id: string;
+    name: string;
+    variations: Array<{
+      id: string;
+      url: string;
+      mimeType: string;
+      width: number;
+      height: number;
+      duration?: number;
+    }>;
+  };
+};
+
+const ajv = new Ajv({ formats: { uuid: true, email: true, uri: true } });
+const requestSchema: ReturnType<JSON['parse']> = yaml.load(
+  fs.readFileSync('test/support/server/fakeRemotes/fakeAMS/requestSchema.yaml', 'utf8')
+);
+
+const mockAssetData: MockAssetData = JSON.parse(
+  fs.readFileSync('test/support/server/fakeRemotes/fakeAMS/mockAssetData.json', 'utf8')
+);
+
+export function setupFakeAMS(): void {
+  // Listen for AMS requests through RabbitMQ
+  setupAMSQueueListener();
+
+  // Setup HTTP endpoint for serving test fixture files
+  webApp.get().get('/test/fixtures/ams/:filename', serveTestFixture);
+
+  // Ignore from OpenAPI
+  openAPIIgnoreRegexString.push('/test/fixtures/ams/');
+  openAPIIgnoreList.push(new RegExp('/test/fixtures/ams/'));
+}
+
+/* eslint-disable-next-line max-lines-per-function */
+async function setupAMSQueueListener(): Promise<void> {
+  // Delay setup until after app starts and connections are established
+  /* eslint-disable-next-line max-lines-per-function */
+  setTimeout(async () => {
+    try {
+      const connection = AMQPConnection.get();
+
+      // Create a test queue for AMS requests
+      const channel = await connection.createChannel();
+      const requestQueue = 'ams.request.test';
+
+      await channel.assertQueue(requestQueue, { durable: true });
+
+      console.log('Fake AMS queue listener setup complete');
+
+      await channel.consume(requestQueue, async (message) => {
+        if (!message) return;
+
+        try {
+          const request = JSON.parse(message.content.toString());
+          console.log('Fake AMS received request:', request);
+
+          if (isValidAMSRequest(request)) {
+            await handleAMSRequest(request);
+          } else {
+            console.error('Invalid AMS request received:', request);
+          }
+
+          channel.ack(message);
+        } catch (error) {
+          console.error('Error processing AMS request:', error);
+          channel.nack(message, false, false);
+        }
+      });
+    } catch (error) {
+      console.error('Failed to setup AMS queue listener:', error);
+    }
+  }, 3000); // Wait 3 seconds for app to fully initialize
+}
+
+async function handleAMSRequest(request: AMSRequest): Promise<void> {
+  const { requestId, replyTo, payload } = request;
+  const assetId = payload.query.value;
+
+  console.log(`Fake AMS handling request for asset: ${assetId}`);
+
+  // Check if asset exists in mock data
+  await (
+    assetId.startsWith('error-') || !mockAssetData[assetId] ? sendErrorResponse(requestId, replyTo, assetId
+    ) : sendSuccessResponse(requestId, replyTo, assetId));
+}
+
+/* eslint-disable-next-line max-lines-per-function */
+async function sendSuccessResponse(
+  requestId: string, replyTo: { exchangeName: string; routingKey: string }, assetId: string
+): Promise<void> {
+  const assetData = mockAssetData[assetId];
+
+  const response = {
+    type: 'searchAssets',
+    requestId,
+    payload: {
+      asset: {
+        id: assetData.id,
+        type: assetData.variations.some(v => v.mimeType.startsWith('video/')) ? 'video' : 'image',
+        variations: assetData.variations.map(variation => ({
+          url: variation.url,
+          height: variation.height,
+          mimeType: variation.mimeType
+        })),
+        metadata: {
+          name: assetData.name
+        }
+      }
+    }
+  };
+
+  console.log(`Fake AMS sending success response for ${assetId}:`, response);
+
+  // Send response via AMQP with delay like ComfyUI2 does
+  setTimeout(async () => {
+    await publishAMQPMessage(
+      AMQPConnection.getDefaultChannel(),
+      JSON.stringify(response),
+      replyTo.exchangeName,
+      replyTo.routingKey
+    );
+  }, 200);
+}
+
+/* eslint-disable-next-line max-lines-per-function */
+async function sendErrorResponse(
+  requestId: string,
+  replyTo: { exchangeName: string; routingKey: string },
+  assetId: string,
+  customMessage?: string
+): Promise<void> {
+  const response = {
+    type: 'searchAssets',
+    requestId,
+    error: {
+      code: 'ASSET_NOT_FOUND',
+      message: customMessage || `Asset with ID '${assetId}' not found`,
+      details: {
+        assetId,
+        timestamp: new Date().toISOString()
+      }
+    }
+  };
+
+  console.log(`Fake AMS sending error response for ${assetId}:`, response);
+
+  // Send error response via AMQP with delay
+  setTimeout(async () => {
+    await publishAMQPMessage(
+      AMQPConnection.getDefaultChannel(),
+      JSON.stringify(response),
+      replyTo.exchangeName,
+      replyTo.routingKey
+    );
+  }, 200);
+}
+
+function serveTestFixture(request: Request, response: Response): void {
+  const {filename} = request.params;
+  const filePath = path.join(process.cwd(), 'test/fixtures/ams', filename);
+
+  console.log(`Serving test fixture: ${filename} from ${filePath}`);
+
+  if (!fs.existsSync(filePath)) {
+    console.error(`Test fixture not found: ${filePath}`);
+    response.status(404).send('Test fixture not found');
+    return;
+  }
+
+  const content = fs.readFileSync(filePath);
+
+  // Set appropriate content type based on file extension
+  if (filename.endsWith('.png')) {
+    response.type('image/png');
+  } else if (filename.endsWith('.jpg') || filename.endsWith('.jpeg')) {
+    response.type('image/jpeg');
+  } else if (filename.endsWith('.mp4')) {
+    response.type('video/mp4');
+  }
+
+  response.send(content);
+}
+
+function isValidAMSRequest(request: unknown): request is AMSRequest {
+  const validate = ajv.compile(requestSchema);
+  return validate(request);
+}
+
diff --git a/test/support/server/fakeRemotes/fakeAMS/mockAssetData.json b/test/support/server/fakeRemotes/fakeAMS/mockAssetData.json
new file mode 100644
index 000000000..7002556aa
--- /dev/null
+++ b/test/support/server/fakeRemotes/fakeAMS/mockAssetData.json
@@ -0,0 +1,86 @@
+{
+  "image-asset-001": {
+    "id": "image-asset-001",
+    "name": "Sample Image Asset",
+    "variations": [
+      {
+        "id": "var-1", 
+        "url": "http://localhost:8001/test/fixtures/ams/sample-image.png",
+        "mimeType": "image/png",
+        "width": 1920,
+        "height": 1080
+      },
+      {
+        "id": "var-2",
+        "url": "http://localhost:8001/test/fixtures/ams/sample-image-small.png", 
+        "mimeType": "image/png",
+        "width": 960,
+        "height": 540
+      }
+    ]
+  },
+  "video-asset-001": {
+    "id": "video-asset-001",
+    "name": "Sample Video Asset",
+    "variations": [
+      {
+        "id": "var-1",
+        "url": "http://localhost:8001/test/fixtures/ams/sample-video.mp4",
+        "mimeType": "video/mp4",
+        "width": 1920,
+        "height": 1080,
+        "duration": 30.5
+      }
+    ]
+  },
+  "prores-asset-001": {
+    "id": "prores-asset-001", 
+    "name": "ProRes Video Asset",
+    "variations": [
+      {
+        "id": "var-1",
+        "url": "http://localhost:8001/test/fixtures/ams/sample-video.mp4",
+        "mimeType": "video/quicktime",
+        "width": 1920,
+        "height": 1080,
+        "duration": 30.5
+      }
+    ]
+  },
+  "multi-format-asset": {
+    "id": "multi-format-asset",
+    "name": "Asset with Multiple Formats",
+    "variations": [
+      {
+        "id": "png-var",
+        "url": "http://localhost:8001/test/fixtures/ams/sample-image.png",
+        "mimeType": "image/png",
+        "width": 1920,
+        "height": 1080
+      },
+      {
+        "id": "jpg-var", 
+        "url": "http://localhost:8001/test/fixtures/ams/sample-image-small.png",
+        "mimeType": "image/jpeg",
+        "width": 1920,
+        "height": 1080
+      },
+      {
+        "id": "mp4-var",
+        "url": "http://localhost:8001/test/fixtures/ams/sample-video.mp4",
+        "mimeType": "video/mp4",
+        "width": 1920,
+        "height": 1080,
+        "duration": 30.5
+      },
+      {
+        "id": "mov-var",
+        "url": "http://localhost:8001/test/fixtures/ams/sample-video.mp4", 
+        "mimeType": "video/quicktime",
+        "width": 1920,
+        "height": 1080,
+        "duration": 30.5
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/test/support/server/fakeRemotes/fakeAMS/requestSchema.yaml b/test/support/server/fakeRemotes/fakeAMS/requestSchema.yaml
new file mode 100644
index 000000000..0372f8712
--- /dev/null
+++ b/test/support/server/fakeRemotes/fakeAMS/requestSchema.yaml
@@ -0,0 +1,44 @@
+type: object
+required: [type, requestId, replyTo, payload]
+additionalProperties: false
+properties:
+  type:
+    type: string
+    enum: [searchAssets]
+  requestId:
+    type: string
+    format: uuid
+  replyTo:
+    type: object
+    additionalProperties: false
+    required: [exchangeName, routingKey]
+    properties:
+      exchangeName:
+        type: string
+      routingKey:
+        type: string
+  payload:
+    type: object
+    additionalProperties: false
+    required: [offset, limit, query]
+    properties:
+      offset:
+        type: integer
+        minimum: 0
+      limit:
+        type: integer
+        minimum: 1
+        maximum: 100
+      query:
+        type: object
+        additionalProperties: false
+        required: [field, operator, value]
+        properties:
+          field:
+            type: string
+            enum: [id]
+          operator:
+            type: string
+            enum: [equals]
+          value:
+            type: string
\ No newline at end of file
