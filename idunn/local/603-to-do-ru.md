# TODO: Дожать AMS URL/RAW поддержку

## TL;DR
- `src/server/services/resources/storage.ts:getRaw` и `mapToURLs` при попытке работать с `{ ams: ... }` падают с `Error('AMS ... not implemented yet')`.
- Без этого AMS-ресурсы нельзя прокидывать в сценарии, где граф или внешний код ждёт URL/сырые данные (например, предпросмотры, CDN, дебаг-утилиты).
- Браузерная `loadResource` оставляем как есть: она не должна напрямую тянуть AMS, и сейчас её «дыра» осознанная.

## Текущее состояние
- `get()` для AMS завязан на `getAMSResourceViaRabbitMQ`, который запрашивает asset у Freya, выбирает лучшую вариацию и возвращает буфер с нормализацией.
- Остальные методы (`getRaw`, `mapToURLs`, `url`) тупо `throw` при `isValidAMSResourceReference` (`src/server/services/resources/storage.ts:167`, `:195`).
- Браузерный прелоад (`getAssetURLs`) жёстко возвращает `[]`, когда источник `ams` (`src/graphics/browser/operations/loadResource.ts:65`). Это задокументированный костыль, чтобы фронт не лез, куда не надо.

## Почему это важно
- Любой код, который ожидает URL (например, AssetPreloader или внешние интеграции), упадёт, если к нему прилетит AMS-ссылка.
- Нельзя выдать «сырой» файл, если его нужно переслать дальше (экспорт, оболочка, отладка).
- Пока что мы живём на прямом буфере, но следующий тикет легко упрётся в этот `throw`.

## План, как дожать
1. **Вынести повторяемую логику**
   - Сделать helper `fetchAmsVariation(assetId, options)` → возвращает `{ buffer, variation, asset }`.
   - Реюзить его в текущем `getAMSResourceViaRabbitMQ`.
2. **`getRaw`**
   - При `ams` дергать helper и возвращать `buffer` _без_ `ensureImageProperties` (сырой ответ AMS).
   - Добавить in-memory/Redis кэш по `assetId`, чтобы не гонять RabbitMQ на каждое обращение.
3. **`mapToURLs` / `url`**
   - Вариант А: хранить скачанный буфер в blob storage → `buildResourceRef` → `presignedUrl`.
   - Вариант B: если можем доверять Freya URL, то прокидывать их напрямую (нужно обсудить безопасность/CORS).
   - Для A придётся держать мапу `{ assetId -> resourceRef }` + политику TTL/очистки.
4. **Общая устойчивость**
   - Таймауты и ретраи как в `getAMSResourceViaRabbitMQ`.
   - Пушить метрики/логи, чтобы видно было, сколько раз используем URL-режим.
5. **Тесты**
   - Интеграционный сценарий: `mapToURLs({ ams: 'image-asset-001' })` → пресайнед ссылка.
   - Юнит на `getRaw` с подменой gateway → проверяем, что буфер не мутируется.

## Почему не трогаем браузер
- Фронт не знает, что такое AMS, и не имеет прямого доступа к Freya (RabbitMQ, приватные HTTP).
- Даже если дать URL, CORS и авторизация всё равно не пройдут без бэкенд-прокси.
- `loadResource` в браузере по-прежнему должна получать уже готовый buffer из сервера. Прелоад AMS через фронт сломает архитектуру и безопасность.
- Добавлять «фиктивный» прелоад ради галочки бессмысленно: он либо упадёт, либо продублирует серверную работу.

## Решения по «открытым вопросам»
- **Общий доступ к данным.** Поднимаем helper-кэш `fetchAmsVariation` → `{ assetId, variationId }` ключ, кешируем результат в памяти (LRU) и, если уже лежит в blob, переиспользуем тот же `resourceRef`. Отдельный API не нужен, достаточно общего helper, который используют `get()`, `getRaw()` и `mapToURLs`.
- **TTL/хранение в blob.** Сохраняем variation в Azure под детерминированным ref (`ams/<assetId>/<variationId>`). Повторный запрос просто перезапишет файл. Для выдачи пресайнов используем существующий `blobStorage.urlExpirationTime` (уже 3 дня). Дополнительный cron не нужен, Azure lifecycle и детерминированные имена не плодят мусор.
- **Флажок окружений.** URL-режим включаем автоматически при `config.ams.enabled`. Если надо отключить — достаточно текущего `ams.enabled=false`. Дополнительный toggler не заводим, чтобы не плодить конфигов.

Запарковали здесь, чтобы не забыть, куда копать, когда появится реальный кейс.
