# code and docs
- check src/jsonSchemas for typings and validations, types are autogenerated based on jsonSchemas
- check documentation/ for schema definitions and API specs
- check local/ for our generated documentation
- src/browser is not interesting for us, we are backend devs

# schema-first architecture
- **CRITICAL**: ALL types come from YAML schemas, never create manual TypeScript types
- YAML schemas are source of truth: `documentation/api/schemas/`
- Generated types appear in: `src/jsonSchemas/` and `src/types/`
- Build command: `npm run build-json-schema-types`
- Always run type generation after schema changes
- Use generated type guards and validation, don't write custom ones
- Follow existing schema patterns when adding new types

# naming
- use camelCase for file names
- follow existing schema naming conventions in YAML files
- be consistent with generated type names

# workflow
- when writing impl plans do not behave like an idiot PM with estimates and all that shit, you are writing docs for you and me
- think and code like a senior and pro
- use elegant and concise approach
- follow the established code patterns from the codebase 
- **schema-first**: modify YAML schemas first, then run `npm run build-json-schema-types`
- be sure to typecheck when you're done making a series of code changes
- follow lint rules
- always add return types
- do not use any
- leverage existing generated types and validation infrastructure
- maintain consistency with the schema-first architecture throughout

# type safety rules
- use schema-generated types, never duplicate type definitions manually
- import types from generated files: `src/jsonSchemas/` or `src/types/`
- use generated type guards: `isValidAMSResourceReference()`, etc.
- leverage runtime validation through generated JSON schemas
- ensure type consistency between compile-time and runtime validation
