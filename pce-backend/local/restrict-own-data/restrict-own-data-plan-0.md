# План реализации: Restrict users to only read/write their own data (без DB RLS)

Цель: гарантировать, что студент читает/пишет только свои данные. Убрать возможность подмены studentId на клиенте. Усилить скоупинг на уровне приложения: добавить явный student_id во все студентские таблицы и везде фильтровать по нему.

Охват: роль student (основной). Teacher/admin остаются по текущим правилам. DB-RLS не используем.

Ветка: feat/restrict-own-data

## Высокоуровневая стратегия
- Убираем studentId из публичных API. На старте ассессмента резолвим студента из JWT (login → student.id).
- Добавляем столбец student_id в таблицы с персональными данными студента:
  - question_response, student_attribute_score, game_save, game_save_history, career_match
- Бэкфилл student_id через связи со student_assessment/game_save.
- Делаем student_id NOT NULL и добавляем индексы.
- На запись: всегда проставляем student_id.
- На чтение/апдейт/удаление: добавляем WHERE <table>.student_id = :currentStudentId (и/или проверяем владение assessment перед действием).
- Обновляем API Spec и e2e.

## Изменения API

### POST /api/student-assessment
- Request: { "careerAssessmentId": 1 } (без studentId)
- Backend: извлекаем login из JWT, находим student.id, используем его
- Поведение: одна активная сессия на (student_id, career_assessment_id); ответ { id, currentTurn: 1, startDate }

### Остальные эндпоинты
- Не принимать studentId в публичном API
- Любое действие по assessmentId: проверять владение до выполнения

## DDL: изменения напрямую в V1__create_schema.sql (без ALTER)

Так как мы на ранней стадии, вносим изменения непосредственно в исходную миграцию `src/main/resources/db/migration/V1__create_schema.sql`. Ниже — финальные определения затронутых таблиц (выписаны только изменяемые таблицы). Требуется заменить соответствующие блоки CREATE TABLE и индексы.

Важно: добавляем `student_id BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE` и необходимые индексы.

```sql
-- question_response
CREATE TABLE question_response (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_assessment_id BIGINT NOT NULL REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    question_id         BIGINT NOT NULL REFERENCES question(id),
    attribute_one_id    BIGINT NOT NULL REFERENCES attribute(id),
    value_one           NUMERIC NOT NULL,
    attribute_two_id    BIGINT REFERENCES attribute(id),
    value_two           NUMERIC
);
CREATE INDEX idx_qr_assessment ON question_response (student_assessment_id);
CREATE INDEX idx_qr_student_id ON question_response (student_id);
```

```sql
-- student_attribute_score
CREATE TABLE student_attribute_score (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_assessment_id BIGINT NOT NULL REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    attribute_id        BIGINT NOT NULL REFERENCES attribute(id),
    total_value         NUMERIC NOT NULL,
    normalized_value    NUMERIC NOT NULL
        CHECK (normalized_value BETWEEN -1 AND 1)
);
CREATE UNIQUE INDEX uniq_student_attr ON student_attribute_score (student_assessment_id, attribute_id);
CREATE INDEX idx_sas_student_id ON student_attribute_score (student_id);
```

```sql
-- game_save (1:1 с assessment)
CREATE TABLE game_save (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    assessment_id       BIGINT NOT NULL UNIQUE REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    game_data           BYTEA NOT NULL,
    current_game_turn   INTEGER NOT NULL,
    last_save_date      TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_game_save_student_id ON game_save (student_id);
```

```sql
-- game_save_history (опциональная аудит-таблица)
CREATE TABLE game_save_history (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    game_save_id        BIGINT NOT NULL REFERENCES game_save(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    game_turn           INTEGER NOT NULL,
    save_date           TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_gsh_student_id ON game_save_history (student_id);
```

```sql
-- career_match
CREATE TABLE career_match (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_assessment_id BIGINT NOT NULL REFERENCES student_assessment(id) ON DELETE CASCADE,
    student_id          BIGINT NOT NULL REFERENCES student(id) ON DELETE CASCADE,
    career_id           BIGINT NOT NULL REFERENCES career(id),
    match_score         NUMERIC NOT NULL
);
CREATE INDEX idx_career_match_assessment ON career_match (student_assessment_id);
CREATE INDEX idx_career_match_student_id ON career_match (student_id);
CREATE INDEX idx_career_match_score ON career_match (student_assessment_id, match_score DESC);
```

Примечания:
- Остальная схема (таблицы career, question_type, question и т.д.) остаётся без изменений.
- Индексы по student_id добавлены для всех новых столбцов.
- Уникальность одной активной сессии можно оставить на уровне приложения или добавить в этом же файле частичный UNIQUE индекс на `student_assessment` (опционально).

## Backend изменения

### Security/Identity
- SecurityHelper.getCurrentUserDetails(): login, role, org
- Находим student по login (+org при необходимости)

### Контроллеры (точки вмешательства)
- AssessmentController
  - POST /api/student-assessment: убрать studentId из DTO, derive из JWT
  - POST /api/student-assessment/{id}/complete: проверка владения assessment
- QuestionController
  - POST /api/question-response: проверка владения assessment; INSERT с student_id
- GameSaveController
  - PUT/GET /api/game-save/{assessmentId}: проверка владения; вставка/чтение с фильтром по student_id
- GameBatchSaveController
  - POST /api/game-batch-save: проверка владения; массовые вставки с student_id
- CareerController
  - preview/matches: оставить проверку владения; можно добавить фильтр по student_id в SQL как доп. предохранитель

### Сервисы
- AssessmentService: старт без studentId, одна активная, создание student_assessment
- ScoringService: при complete вставки в student_attribute_score и career_match с student_id
- QuestionService: вставка ответов с student_id
- GameSaveService: upsert game_save и вставка game_save_history с student_id
- CareerService: проверки владения уже есть; при желании — добавить фильтр по student_id в SQL

### SQL/DSL правки
- INSERT-ы добавляют student_id
- SELECT/UPDATE/DELETE фильтруют по student_id и assessmentId

## Обновление документации
- documents/srs/Pce Api Spec v.0.3.txt
  - Обновить POST /api/student-assessment: request только careerAssessmentId; поведение derive из JWT; примеры
  - Для эндпоинтов по assessmentId указать: пользователь должен владеть ассессментом (403/404 иначе)

## Изменения e2e
- e2e-test/studentJourney.ts
  - startAssessment() без studentId; тело { careerAssessmentId }
  - Остальное без изменений; опционально негатив-тест на чужой assessmentId

## Тестирование

### Unit/Integration
- Старт ассессмента без studentId: derive, 409 при активной сессии
- question_response: student_id проставляется; запись чужого assessmentId невозможна (403/404)
- game_save upsert/GET: student_id проставляется; чтение ограничено владельцем
- complete: записи в student_attribute_score и career_match имеют корректный student_id
- preview/career-match: только владелец

### E2E
- Сценарий зелёный в dev/test (mock auth)
- (Опционально) негатив-проверка на доступ к чужому assessmentId

### Acceptance Criteria
- Публичные API не принимают studentId
- В студентских таблицах student_id заполнен и NOT NULL
- Все операции скоуплены по student_id и/или проверке владения assessment
- E2E зелёный, API Spec обновлён

## Риски
- Пропустить добавление student_id в один из INSERT → риск утечки; нужен тщательный ревью
- Индексы по student_id обязательны для производительности

## Порядок выката
1) Слить ветку feat/restrict-own-data
2) Прогнать миграции Flyway
3) Деплой
4) Прогнать e2e smoke

